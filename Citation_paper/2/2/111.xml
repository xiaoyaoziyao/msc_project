<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="3.0" xml:lang="EN">
  <front>
    <journal-meta><journal-id journal-id-type="nlm-ta">PLoS ONE</journal-id><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="pmc">plosone</journal-id><!--===== Grouping journal title elements =====--><journal-title-group><journal-title>PLoS ONE</journal-title></journal-title-group><issn pub-type="epub">1932-6203</issn><publisher>
        <publisher-name>Public Library of Science</publisher-name>
        <publisher-loc>San Francisco, USA</publisher-loc>
      </publisher></journal-meta>
    <article-meta><article-id pub-id-type="publisher-id">PONE-D-11-20643</article-id><article-id pub-id-type="doi">10.1371/journal.pone.0036898</article-id><article-categories>
        <subj-group subj-group-type="heading">
          <subject>Research Article</subject>
        </subj-group>
        <subj-group subj-group-type="Discipline-v2">
          <subject>Biology</subject>
          <subj-group>
            <subject>Computational biology</subject>
          </subj-group>
          <subj-group>
            <subject>Evolutionary biology</subject>
            <subj-group>
              <subject>Evolutionary processes</subject>
              <subj-group>
                <subject>Mutation</subject>
              </subj-group>
            </subj-group>
            <subj-group>
              <subject>Evolutionary systematics</subject>
              <subj-group>
                <subject>Phylogenetics</subject>
              </subj-group>
            </subj-group>
            <subj-group>
              <subject>Comparative genomics</subject>
              <subject>Evolutionary genetics</subject>
              <subject>Genomic evolution</subject>
            </subj-group>
          </subj-group>
          <subj-group>
            <subject>Genomics</subject>
            <subj-group>
              <subject>Genome analysis tools</subject>
              <subj-group>
                <subject>Gene prediction</subject>
                <subject>Genome scans</subject>
              </subj-group>
            </subj-group>
            <subj-group>
              <subject>Comparative genomics</subject>
              <subject>Genome evolution</subject>
            </subj-group>
          </subj-group>
        </subj-group>
        <subj-group subj-group-type="Discipline-v2">
          <subject>Computer science</subject>
          <subj-group>
            <subject>Computer modeling</subject>
          </subj-group>
          <subj-group>
            <subject>Computing methods</subject>
            <subj-group>
              <subject>Mathematical computing</subject>
            </subj-group>
          </subj-group>
          <subj-group>
            <subject>Numerical analysis</subject>
          </subj-group>
        </subj-group>
        <subj-group subj-group-type="Discipline">
          <subject>Genetics and Genomics</subject>
          <subject>Computational Biology</subject>
          <subject>Computer Science</subject>
          <subject>Evolutionary Biology</subject>
        </subj-group>
      </article-categories><title-group><article-title>Developing and Applying Heterogeneous Phylogenetic Models with XRate</article-title><alt-title alt-title-type="running-head">Phylogenetic Modeling with XRate</alt-title></title-group><contrib-group>
        <contrib contrib-type="author" xlink:type="simple">
          <name name-style="western">
            <surname>Westesson</surname>
            <given-names>Oscar</given-names>
          </name>
        </contrib>
        <contrib contrib-type="author" xlink:type="simple">
          <name name-style="western">
            <surname>Holmes</surname>
            <given-names>Ian</given-names>
          </name>
          <xref ref-type="aff" rid="aff1"/>
          <xref ref-type="corresp" rid="cor1">
            <sup>*</sup>
          </xref>
        </contrib>
      </contrib-group><aff id="aff1">          <addr-line>Department of Bioengineering, University of California, Berkeley, California, United States of America</addr-line>       </aff><contrib-group>
        <contrib contrib-type="editor" xlink:type="simple">
          <name name-style="western">
            <surname>Ouzounis</surname>
            <given-names>Christos A.</given-names>
          </name>
          <role>Editor</role>
          <xref ref-type="aff" rid="edit1"/>
        </contrib>
      </contrib-group><aff id="edit1">The Centre for Research and Technology, Hellas, Greece</aff><author-notes>
        <corresp id="cor1">* E-mail: <email xlink:type="simple">ihh@berkeley.edu</email></corresp>
        <fn fn-type="con">
          <p>Conceived and designed the experiments: OW IH. Performed the experiments: OW IH. Analyzed the data: OW. Contributed reagents/materials/analysis tools: OW IH. Wrote the paper: OW IH.</p>
        </fn>
      <fn fn-type="conflict">
        <p>The authors have declared that no competing interests exist.</p>
      </fn></author-notes><pub-date pub-type="collection">
        <year>2012</year>
      </pub-date><pub-date pub-type="epub">
        <day>5</day>
        <month>6</month>
        <year>2012</year>
      </pub-date><volume>7</volume><issue>6</issue><elocation-id>e36898</elocation-id><history>
        <date date-type="received">
          <day>18</day>
          <month>10</month>
          <year>2011</year>
        </date>
        <date date-type="accepted">
          <day>9</day>
          <month>4</month>
          <year>2012</year>
        </date>
      </history><!--===== Grouping copyright info into permissions =====--><permissions><copyright-year>2012</copyright-year><copyright-holder>Westesson, Holmes</copyright-holder><license><license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p></license></permissions><abstract>
        <p>Modeling sequence evolution on phylogenetic trees is a useful technique in computational biology. Especially powerful are models which take account of the heterogeneous nature of sequence evolution according to the “grammar” of the encoded gene features. However, beyond a modest level of model complexity, manual coding of models becomes prohibitively labor-intensive. We demonstrate, via a set of case studies, the new built-in model-prototyping capabilities of XRate (macros and Scheme extensions). These features allow rapid implementation of phylogenetic models which would have previously been far more labor-intensive. XRate 's new capabilities for lineage-specific models, ancestral sequence reconstruction, and improved annotation output are also discussed. XRate 's flexible model-specification capabilities and computational efficiency make it well-suited to developing and prototyping phylogenetic grammar models. XRate is available as part of the DART software package: <ext-link ext-link-type="uri" xlink:href="http://biowiki.org/DART" xlink:type="simple">http://biowiki.org/DART</ext-link>.</p>
      </abstract><funding-group><funding-statement>This research was funded from an NIH Research Project Grant Program (R01). The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement></funding-group><counts>
        <page-count count="9"/>
      </counts></article-meta>
  </front>
  <body>
    <sec id="s1">
      <title>Introduction</title>
      <p>Phylogenetics, the modeling of evolution on trees, is an extremely powerful tool in computational biology. The better we can model a system, the more can learn from it, and vice-versa. Especially attractive, given the plethora of available sequence data, is modeling sequence evolution at the molecular level. Models describing the evolution of a single nucleotide began simply (e.g. JC69 <xref ref-type="bibr" rid="pone.0036898-Jukes1">[1]</xref>), later evolving to capture such biological features as transition/transversion bias (e.g. K80 <xref ref-type="bibr" rid="pone.0036898-Kimura1">[2]</xref>) and unequal base frequencies (e.g. HKY85 <xref ref-type="bibr" rid="pone.0036898-Hasegawa1">[3]</xref>). Felsenstein's “pruning” algorithm allows combining these models with phylogenetic trees to compute the likelihood of multiple sequences <xref ref-type="bibr" rid="pone.0036898-Felsenstein1">[4]</xref>.</p>
      <p>As powerful as phylogenetic models are for explaining the evolutionary depth of a sequence alignment, they are even more powerful when combined with a model for the feature structure: the partition of the alignment into regions, each evolving under a particular model. The phylogenetic grammar, or “phylo-grammar”, is one such class of models. Combining hidden Markov models (and, more generally, stochastic grammars) and phylogenetic substitution models provides computational modelers with a rich set of comparative tools to analyze multiple sequence alignments (MSAs): gene prediction, homology detection, finding structured RNA, and detecting changes in selective pressure have all been approached with this general framework <xref ref-type="bibr" rid="pone.0036898-Meyer1">[5]</xref>–<xref ref-type="bibr" rid="pone.0036898-Garber1">[8]</xref>. Readers unfamiliar with phylo-grammars may benefit from relevant descriptions and links available here: <ext-link ext-link-type="uri" xlink:href="http://biowiki.org/PhyloGrammars" xlink:type="simple">http://biowiki.org/PhyloGrammars</ext-link> or the original paper describing XRate <xref ref-type="bibr" rid="pone.0036898-Klosterman1">[9]</xref>. Also, a collection of animations depicting various evolutionary models at work (generating multiple alignments or evolving sequences) has been compiled here: <ext-link ext-link-type="uri" xlink:href="http://biowiki.org/PhyloFilm" xlink:type="simple">http://biowiki.org/PhyloFilm</ext-link>.</p>
      <p>While the mathematics of sequence modeling is straightforward, manual implementation can quickly become the limiting factor in iterative development of a computational pipeline. To streamline this step, general modeling platforms have been developed. For instance, Exonerate allows users to specify a wide variety of common substitution and gap models when aligning pairs of sequences <xref ref-type="bibr" rid="pone.0036898-Slater1">[10]</xref>. Dynamite uses a specification file to generate code for dynamic programming routines <xref ref-type="bibr" rid="pone.0036898-Birney1">[11]</xref>. HMMoC is a similar model compiler sufficiently general to work with arbitrary HMMs <xref ref-type="bibr" rid="pone.0036898-Lunter1">[12]</xref>. The BEAST program allows users to choose from a wide range of phylogenetic substitution models while also sampling over trees <xref ref-type="bibr" rid="pone.0036898-Drummond1">[13]</xref>. The first three of these are non-phylogenetic, only able to model related pairs of sequences. Dynamite and HMMoC are unique in that they allow definition of arbitrary models via specification files, whereas users of BEAST and Exonerate are limited to the range of models which have been hard-coded in the respective programs.</p>
      <p>Defining models' structure manually can be limiting as models grow in size and/or complexity. For instance, a Nielsen-Yang model incorporating both selection and transition/transversion bias has nearly 4000 entries - far too many for a user to manually specify <xref ref-type="bibr" rid="pone.0036898-Yang1">[14]</xref>. Such a large matrix requires specific model-generating code to be written and integrated with the program in use - not always possible or practical for the user depending on the program's implementation.</p>
      <p>XRate is a phylogenetic modeling program that implements the key parameterization and inference algorithms given two ingredients: a user-specified phylo-grammar, and a multiple sequence alignment. (A phylogeny can optionally be specified by the user, or it can be inferred by the program.) XRate 's models describe the parametric structure of substitution rate matrices, along with grammatical rules governing which rate matrices can account for which alignment columns. This essentially amounts to partitioning the alignment (e.g. marking up exon boundaries and reading frames) and factoring in the transitions between the different types of region.</p>
      <p>Parameter estimation and decoding (alignment annotation) algorithms are built in, allowing fast model prototyping and fitting. Model training (estimating the rate and probability parameters of the grammar) is done via a form of the Expectation Maximization (EM) algorithm, described in more detail in the original XRate paper <xref ref-type="bibr" rid="pone.0036898-Klosterman1">[9]</xref>. Most recently, XRate allows programmatic model construction via its macros and Scheme extensions. XRate 's built-in macro language allows large, repetitive grammars to be compactly represented, and also enables the model structure to depend on aspects of the data, such as the tree or alignment. Scheme extensions take this even further, interfacing XRate to a full-featured functional scripting language, allowing complex XRate -oriented workflows to be written as Scheme programs.</p>
      <p>In this paper we demonstrate XRate 's new model-specification tools via a set of progressively more complex examples, concluding with XDecoder, a phylo-grammar modeling RNA secondary structure overlapping protein-coding regions. We also describe additional improvements to XRate since its initial publication, namely ancestral sequence reconstruction, GFF/WIG output, and hybrid substitution models. Finally, we show how XRate's features are exposed as function extensions in a dialect of the Scheme programming language, typifying a Functional Programming (FP) style of model development and inference for phylogenetic sequence analysis. Terminology relevant to modeling with XRate are defined in detail in <xref ref-type="supplementary-material" rid="pone.0036898.s003">Text S3</xref>. We also provide an online tutorial for making nontrivial modifications to existing grammars, going step-by-step from a Jukes-Cantor model to an autocorrelated Gamma-distributed rates phylo-HMM: <ext-link ext-link-type="uri" xlink:href="http://biowiki.org/XrateTutorial" xlink:type="simple">http://biowiki.org/XrateTutorial</ext-link>.</p>
    </sec>
    <sec id="s2" sec-type="methods">
      <title>Methods</title>
      <sec id="s2a">
        <title>The XRate generative model</title>
        <p>A phylo-grammar generates an alignment in two steps: nonterminal transformations and token evolution. The sequence of nonterminal transformations comprises the “grammar” portion of a phylo-grammar, and the “phylo” portion refers to the evolution of tokens along a phylogeny. First, transformation rules are repeatedly applied, beginning with the START nonterminal, until only a series of pseudoterminals remains. From each group of pseudoterminals (a group may be a single column, two “paired” columns in an RNA structure, or a codon triplet of columns), a tuple of tokens is sampled from the initial distribution of the chain corresponding to the pseudoterminal. These tokens then evolve down the phylogenetic tree according to the mutation rules of the chain, resulting in the observed alignment columns.</p>
        <p>If the nonterminal transformations contain no bifurcations and all emissions occur on the same side of the nonterminal, the grammar is a phylogenetic hidden Markov model (phylo-HMM), a special subclass of phylo-grammars. Otherwise, it is a phylogenetic stochastic context-free grammar (phylo-SCFG), the most general class of models implemented by XRate. This distinction, along with other related technical terms, are described in greater detail in <xref ref-type="supplementary-material" rid="pone.0036898.s003">Text S3</xref>, the Glossary of XRate model terminology.</p>
        <p>The generality of XRate requires a slight tradeoff against speed. Since the low-level code implementing core operations is shared among the set of possible models, XRate will generally be slower than programs with source code optimized for a narrower range of models. Computing the Felsenstein likelihood under the HKY85 <xref ref-type="bibr" rid="pone.0036898-Hasegawa1">[3]</xref> model of a 5-taxon, 1 Mb alignment, XRate required 1.25 minutes of CPU time and 116 MB RAM, while PAML required 9 seconds of CPU time and 19 MB RAM for the same operation. Running PFOLD <xref ref-type="bibr" rid="pone.0036898-Knudsen2">[15]</xref> on a 5-taxon, 1 KB alignment required 11 seconds and 164 MB RAM, and running XRate on the same alignment with a comparable grammar required 25 seconds and 62 MB RAM. All programs were run with default settings on a 3.4 GHz Intel i7 processor. Model-fitting also takes longer with XRate: a previous work found that XRate's parameter estimation routines were approximately 130 times slower than those in PAML <xref ref-type="bibr" rid="pone.0036898-Heger1">[16]</xref>.</p>
        <p>In an attempt to improve XRate's performance, we tried using Beagle, a library that provides CPU and accelerated parallel GPU implementations of Felsenstein's algorithm along with related matrix operations <xref ref-type="bibr" rid="pone.0036898-Ayres1">[17]</xref>. We have, however, been so far unable to generate significant performance gains by this method.</p>
        <p>Despite these caveats, XRate has proved to be fast enough for genome-scale applications, such as a screen of <italic>Drosophila</italic> whole-genome alignments <xref ref-type="bibr" rid="pone.0036898-Bradley1">[18]</xref>. Furthermore, it implements a significantly broader range of models than the above-cited tools.</p>
      </sec>
      <sec id="s2b">
        <title>XRate inputs, outputs and operations</title>
        <p>The formulation of the XRate model presented in the previous section is generative: that is, it describes the generation of data on a tree. In practice, the main reason for doing this is to generate simulation data for benchmarking purposes. This is possible using the tool simgram <xref ref-type="bibr" rid="pone.0036898-Varadarajan1">[19]</xref>, which is provided with XRate as part of the DART package.</p>
        <p>Most common use cases for generative models involve not simulation, but inference: that is, reconstructing aspects of the generative process (sequence of nonterminal transformations, token mutations, or grammar parameters) given observed sequence data (in the form of a multiple sequence alignment). Using a phylo-grammar, a set of aligned sequences, and a phylogeny relating these sequences (optionally inferred by XRate), XRate implements the relevant parameterization and inference algorithms, allowing researchers to analyze sequence data without having to implement their own models.</p>
        <p>Sequences are read and written in Stockholm format <xref ref-type="bibr" rid="pone.0036898-The1">[20]</xref> (converters to and from common formats are included with DART). This format allows for the option of embedding a tree in Newick format <xref ref-type="bibr" rid="pone.0036898-The2">[21]</xref> (via the # = GF NH tag) and annotations in GFF format <xref ref-type="bibr" rid="pone.0036898-GFF1">[22]</xref>. By construction, Newick format necessarily specifies a rooted tree, rather than an unrooted one. However, the root placement is only relevant for time-irreversible models; when using time-reversible models, the placement of the root is arbitrary and can safely be ignored. Given these input ingredients, a call to XRate proceeds in the following order (more detail is provided at <ext-link ext-link-type="uri" xlink:href="http://biowiki.org/XRATE" xlink:type="simple">http://biowiki.org/XRATE</ext-link> and <ext-link ext-link-type="uri" xlink:href="http://biowiki.org/XrateFormat" xlink:type="simple">http://biowiki.org/XrateFormat</ext-link>):</p>
        <list list-type="order">
          <list-item>
            <p>The Stockholm file and grammar alphabet are parsed (as macros may depend on these).</p>
          </list-item>
          <list-item>
            <p>Any grammar macros are expanded, followed by Scheme functions.</p>
          </list-item>
          <list-item>
            <p>If requested, or a tree was not provided in the input data, one is estimated using neighbor-joining <xref ref-type="bibr" rid="pone.0036898-Saitou1">[23]</xref>. As noted above, this is a rooted tree, but the root placement is arbitrary if a time-reversible model is used.</p>
          </list-item>
          <list-item>
            <p>Grammar parameters are estimated (if requested).</p>
          </list-item>
          <list-item>
            <p>Alignment is annotated (if requested).</p>
          </list-item>
          <list-item>
            <p>Ancestral sequences are reconstructed (if requested).</p>
          </list-item>
        </list>
        <p>After the analysis is complete, the alignment (along with an embedded tree) is printed to the output stream along with ancestral sequences (if requested) as well as any # = GC and # = GR column annotations. GFF and WIG annotations are sent to standard output by default, but these can be directed to separate files by way of the -gff and -wig options, respectively.</p>
      </sec>
    </sec>
    <sec id="s3">
      <title>Results and Discussion</title>
      <sec id="s3a">
        <title>The XRate format macro language for phylo-grammar specification: case studies</title>
        <p>The following sections describe case studies of repetitively-structured models which motivate the need for grammar-generating code. Historically, we have attempted several solutions to the case studies described. We first briefly review the factors that influenced our eventual choice of Scheme as a macro language.</p>
        <p>XRate was preceded by Searls' Prolog-based automata <xref ref-type="bibr" rid="pone.0036898-Searls1">[24]</xref> and Birney's Dynamite parser-generator <xref ref-type="bibr" rid="pone.0036898-Birney1">[11]</xref>, and roughly contemporaneous with Slater's Exonerate <xref ref-type="bibr" rid="pone.0036898-Slater1">[10]</xref> and Lunter's HMMoC <xref ref-type="bibr" rid="pone.0036898-Lunter1">[12]</xref>. In early versions of XRate (circa 2004), and in Exonerate, the only way for the user to specify their own phylo-grammar models was to write C/C++ code that would compile directly against the program's internal libraries. This kind of compilation step significantly slows model prototyping, and impedes re-use of model parameters.</p>
        <p>Current versions of XRate, along with Dynamite and HMMoC, understand a machine-readable grammar format. In the case of XRate, this format is based on Lisp S-expressions. In such formats (as the case studies illustrate) the need arises for code that generates repetitively-structured grammar files. It is often convenient, and sometimes sufficient, to write such grammar-generating code in an external language: for example, we have written Perl, Python and C++ libraries to generate XRate grammar files <xref ref-type="bibr" rid="pone.0036898-Klosterman1">[9]</xref>, <xref ref-type="bibr" rid="pone.0036898-Heger1">[16]</xref>. However, this approach still has the disadvantage (from a programmer's or model developer's perspective) that (a) code to generate real grammars tends to require an ungainly mix of grammar-related S-expression constants embedded in Perl/Python/C++ code, and (b) the requirement for an explicit model-generation step can delay prototyping and evaluation of new phylo-grammar models.</p>
        <p>XRate's macro language provides an alternate way to generate repetitive models within XRate, without having to resort to external code-generating scripts. This allows the model-specifying code to remain compact, readable, and easy to edit. As we report in this manuscript, the XRate grammar format now also natively includes a Scheme-based scripting language that can be embedded directly within grammar files, whose syntax blends seamlessly with the S-expression format used by XRate and whose functional nature fits XRate's problem domain. We provide here examples of common phylogenetic models which make use of various macro features, and refer the reader to the online documentation for a complete introduction to XRate's macro features: <ext-link ext-link-type="uri" xlink:href="http://biowiki.org/XrateMacros" xlink:type="simple">http://biowiki.org/XrateMacros</ext-link>. All of the code snippets presented here are available as minimal complete grammars in <xref ref-type="supplementary-material" rid="pone.0036898.s001">Text S1</xref>. The full, trained grammars corresponding to those presented here are available as part of DART. This correspondence is described here: <ext-link ext-link-type="uri" xlink:href="http://biowiki.org/XratePaper2011" xlink:type="simple">http://biowiki.org/XratePaper2011</ext-link></p>
        <sec id="s3a1">
          <title>A repetitively-structured HMM specified using simple macros</title>
          <p>Probabilistic models for the evolution of biological sequences tend to contain repetitive structure. Sometimes, this structure arises as a reflection of symmetries in the phylo-grammar; other times, it arises due to structure in the data, such as the tree or the alignment. While small repetitive models can be written manually, developing richer evolutionary models and grammars often demands writing code to model the underlying structure.</p>
        </sec>
        <sec id="s3a2">
          <title>Markov chain symmetry</title>
          <p>The most familiar source of repetition derives from the substitution model's structure: different substitutions share parameters based on prior knowledge or biological intuition. Perhaps most repetitive is the Jukes-Cantor model for DNA. The matrix entries <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e001" xlink:type="simple"/></inline-formula> denote the rate of substitution from <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e002" xlink:type="simple"/></inline-formula> to <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e003" xlink:type="simple"/></inline-formula>:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0036898.e004" xlink:type="simple"/></disp-formula>Here <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e005" xlink:type="simple"/></inline-formula> is an arbitrary positive rate parameter. The <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e006" xlink:type="simple"/></inline-formula> character denotes the negative sum of the remaining row entries (here equal to <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e007" xlink:type="simple"/></inline-formula> in every case). The parameter <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e008" xlink:type="simple"/></inline-formula> is typically set to <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e009" xlink:type="simple"/></inline-formula> in order that the stochastic process performs, on average, one substitution event per unit of time.</p>
          <p>This matrix can be specified in XRate with two nested loops over alphabet tokens. Each loop over alphabet tokens has the form (&amp;foreach-token X expression…) where expression… is a construct to be expanded for each alphabet token X. Here, expression sets the substitution rate between each pair of source and destination tokens (except for the case when the source and destination tokens are identical, for which case we simply generate an empty list, (), which will be ignored by the XRate grammar parser). We do not explicitly need to write the negative values of the on-diagonal matrix elements (labeled <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e010" xlink:type="simple"/></inline-formula> in the above description of the matrix); XRate will figure these out for itself. To check whether source and destination tokens are equal in the loop, we use a conditional &amp;if statement, which has the form (&amp;if (condition) (expansion-if-true) (expansion-if-false)). The condition is implemented using the &amp;eq macro, which tests if its two arguments are equal. Putting all these together, the nested loops look like this:</p>
          <p>(&amp;foreach-token tok1</p>
          <p> (&amp;foreach-token tok2</p>
          <p>  (&amp;if (&amp;eq tok1 tok2)</p>
          <p>   () ;; If tok1 =  = tok2, expand to an empty list (ignored by parser)</p>
          <p>   (mutate (from (tok1)) (to (tok2)) (rate u)))))</p>
          <p>While this illustrates XRate's looping and conditional capabilities, such a simple model would almost be easier to code by hand. For a slightly more complex application, we turn to the model of Pupko <italic>et al</italic> in their 2008 work. In their RASER program the authors used a chain augmented with a latent variable indicating “slow” or “fast” substitution. Reconstructing ancestral sequences on an HIV phylogeny allowed them to infer locations of transitions between slow and fast modes - indicating a possible gain or loss of selective pressure <xref ref-type="bibr" rid="pone.0036898-Penn1">[25]</xref>. The chain shown below, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e011" xlink:type="simple"/></inline-formula>, shows a simplified version of their model: substitutions <italic>within</italic> rate classes occur according to a JC69 model scaled by rate parameters <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e012" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e013" xlink:type="simple"/></inline-formula> (slow and fast, respectively), and transitions <italic>between</italic> rate classes occur with rates <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e014" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e015" xlink:type="simple"/></inline-formula> (slow <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e016" xlink:type="simple"/></inline-formula> fast and fast <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e017" xlink:type="simple"/></inline-formula> slow, respectively).<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0036898.e018" xlink:type="simple"/></disp-formula>While this chain contains four times as many rates as the basic JC69 model, there are only five parameters: <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e019" xlink:type="simple"/></inline-formula> since the model contains repetition via its symmetry. While manual implementation is possible, the model can be expressed in just a few lines of XRate macro code. Further, additional “modes” of substitution (corresponding to additional quadrants in the matrix above) can be added by editing the first two lines of the following code.</p>
          <p>XRate represents latent variable chains as tuples of the form (state class), where state is a particular state of the Markov chain and class is the value of a hidden variable. In this case, standard DNA characters are augmented with a latent variable indicating substitution rate class: <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e020" xlink:type="simple"/></inline-formula> indicates an <bold>A</bold> which evolves “fast.” The following syntax is used to declare a latent variable chain (in this case, this variable may take values s or f), with the row tag specifying CLASS as the Stockholm # = GR identifier for per-sequence, per-column annotations:</p>
          <p>(hidden-class (row CLASS) (label (s f)))</p>
          <p>Combining loops, conditionals, hidden classes, and the (&amp;cat LIST) function (which concatenates the elements of LIST), we get the following XRate code for the RASER chain:</p>
          <p>(rate (s 0.1) (f 2.0) (r_sf 0.01) (r_fs 0.01) (u 1.0))</p>
          <p>(chain</p>
          <p> (hidden-class (row CLASS) (label (s f)))</p>
          <p> (terminal RASER)</p>
          <p> (&amp;foreach class1 (s f)</p>
          <p>  (&amp;foreach class2 (s f)</p>
          <p>   (&amp;foreach-token tok1</p>
          <p>    (&amp;foreach-token tok2</p>
          <p>     (&amp;if (&amp;eq class1 class2)</p>
          <p>      (&amp;if (&amp;eq tok1 tok2)</p>
          <p>       () ;; if class1 =  = class2 &amp;&amp; tok1 =  = tok2, expand to empty list (will be ignored)</p>
          <p>       ;; The following line handles the case (class1 =  = class2 &amp;&amp; tok1! = tok2)</p>
          <p>       (mutate (from (tok1 class1)) (to (tok2 class2)) (rate u class1)))</p>
          <p>      (&amp;if (&amp;eq tok1 tok2)</p>
          <p>      ;; The following line handles the case (class1! = class2 &amp;&amp; tok1 =  = tok2)</p>
          <p>      (mutate (from (tok1 class1)) (to (tok2 class2)) (rate (&amp;cat r_ class1 class2)))</p>
          <p>      ()))))))) ;; if class1! = class2 &amp;&amp; tok1! = tok2, expand to empty list (ignored)</p>
        </sec>
        <sec id="s3a3">
          <title>Phylo-HMM-induced repetition</title>
          <p>The previous examples both involved specifying the Markov chain component of a phylo-grammar. Coupled with a trivial top-level grammar (a START state and an EMIT state which emits the chain via the EMIT* pseudoterminal), these models describe an alignment where each column's characters evolve according to the same substitution model. A common extension to this is using sequences of hidden states which generate alignment columns according to different substitution models. These “phylo-grammars” (which can include phylo-SCFGs and the more restricted phylo-HMMs) allow modelers to describe and/or detect alignment regions exhibiting different evolutionary patterns. Phylo-HMMs model left-to-right correlations between alignment columns, and phylo-SCFGs are capable of modeling nested correlations (such as “paired” columns in an RNA secondary structure). Readers unfamiliar with phylo-grammars may benefit from relevant descriptions and links available here: <ext-link ext-link-type="uri" xlink:href="http://biowiki.org/PhyloGrammars" xlink:type="simple">http://biowiki.org/PhyloGrammars</ext-link>, animations available here: <ext-link ext-link-type="uri" xlink:href="http://biowiki.org/PhyloFilm" xlink:type="simple">http://biowiki.org/PhyloFilm</ext-link>, and the original paper describing XRate <xref ref-type="bibr" rid="pone.0036898-Klosterman1">[9]</xref>.</p>
          <p>We outline here a phylo-HMM that is simple to describe, but would take a substantial amount of code to implement without XRate 's macro language. The model is based on PhastCons, a program by Siepel <italic>et al</italic> which uses an HMM whose three states (or, in XRate terminology, nonterminals) use substitution models differing only by rate multipliers <xref ref-type="bibr" rid="pone.0036898-Siepel1">[26]</xref>. This model, depicted schematically in <xref ref-type="fig" rid="pone-0036898-g001">Figure 1</xref>, can be used to detect alignment regions evolving at different rates. If the rates of each hidden state correspond to quantiles of the Gamma distribution, then summing over hidden states of this model is equivalent to the commonly-used Gamma model of rate heterogeneity. We provide this grammar in <xref ref-type="supplementary-material" rid="pone.0036898.s001">Text S1</xref>, which is essentially identical to the PhastCons grammar with <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e021" xlink:type="simple"/></inline-formula> states except for its invocation of a Scheme function returning the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e022" xlink:type="simple"/></inline-formula> Gamma-derived rates for a given shape parameter. We can define such a model in XRate easily due to the symmetric structure: all three nonterminals have similar underlying substitution models (varying only by a multiplier) and also similar probabilities of making transitions to other nonterminals via grammar transformation rules.</p>
          <fig id="pone-0036898-g001" position="float">
            <object-id pub-id-type="doi">10.1371/journal.pone.0036898.g001</object-id>
            <label>Figure 1</label>
            <caption>
              <title>The model used by PhastCons, a 3-nonterminal HMM with rate multipliers, is compactly expressed by XRate's macro language.</title>
              <p>Different nonterminal have different evolutionary rates, but they all share the same underlying substitution model. Transition probabilities are shared: a transition between nonterminals happens with probability <italic>leaveProb</italic>, and self-transitions happen with probability <italic>stayProb</italic>. This model (with any number of nonterminals) can be expressed in XRate's macro language in approximately 20 lines of code.</p>
            </caption>
            <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0036898.g001" xlink:type="simple"/>
          </fig>
          <p>The grammar will have nonterminals named “1”, “2”…up to numNonTerms, each one associated with a rate parameter (r_1, r_2…) and substitution chain (chain_1, chain_2…). To express this grammar in XRate macro code, we'll need to declare each of these nonterminals, the production rules which govern transitions between them, rate parameters, and the nonterminal-associated substitution chains. (For a fully-functional grammar, an alphabet is also needed; these are omitted in code snippets included in the main text, but the corresponding grammars in <xref ref-type="supplementary-material" rid="pone.0036898.s001">Text S1</xref> contain alphabets.)</p>
          <p>First, define how many nonterminals the model will have: adding more nonterminals to the model later on can be done simply by adjusting this variable. We define a SEED value to initialize the rate parameters (this is not a random number seed, but rather an initial guess at the parameter value necessary for the EM algorithm to begin), which is done inside a foreach-integer loop using the numNonterms variable. The (foreach-integer X (1 K) expression) expands expression for all values of X from 1 to K. In this case, we define a rate parameter for each of our nonterminals 1.. K.</p>
          <p>(&amp;define numNonterms 3)</p>
          <p>(&amp;define SEED 0.001)</p>
          <p>(&amp;foreach-integer nonterminal (1 numNonterms)</p>
          <p> (rate ((&amp;cat r_ nonterminal) SEED)))</p>
          <p>Next, define a Markov chain for each nonterminal: all make use of the same underlying substitution model (e.g. JC69 <xref ref-type="bibr" rid="pone.0036898-Jukes1">[1]</xref>, HKY85 <xref ref-type="bibr" rid="pone.0036898-Hasegawa1">[3]</xref>) whose entries are stored as Q_a_b for the transition rate between characters a and b. This “underlying” chain must be defined elsewhere - either in an included file (using the (&amp;include) directive), or directly in the grammar file. For instance, we could re-use the JC69 chain, declaring rate parameters for later use:</p>
          <p>(&amp;foreach-token tok1</p>
          <p> (&amp;foreach-token tok2</p>
          <p>  (&amp;if (&amp;eq tok1 tok2)</p>
          <p>   () ;; If tok1 =  = tok2, expand to an empty list (ignored by parser)</p>
          <p>   (rate (&amp;cat Q_ tok1 _ tok2) u))))</p>
          <p>Each nonterminal has an associated substitution model which is Q_a_b scaled by a different rate multiplier r_nonterminal. Using an integer loop, we create a chain for each nonterminal using the rate parameters we defined in the two previous code snippets:</p>
          <p>(&amp;foreach-integer nonterminal (1 numNonterms)</p>
          <p> (chain</p>
          <p>  (terminal (&amp;cat chain_ nonterminal))</p>
          <p>  (&amp;foreach-token tok1</p>
          <p>   (&amp;foreach-token tok2</p>
          <p>    (&amp;if (&amp;eq tok1 tok2)</p>
          <p>     ()</p>
          <p>     (mutate (from (tok1)) (to (tok2))</p>
          <p>     (rate (&amp;cat Q_ tok1 _ tok2) (&amp;cat r_ nonterminal))))))))</p>
          <p>Next, define the production rules which govern the nonterminal transitions. For simplicity of presentation (but not required), we assume here that transitions between nonterminals all occur with probability proportional to leaveProb, and all self-transitions have probability stayProb.</p>
          <p>The pgroup declaration defines a probability distribution over a finite outcome space, with the parameters declared therein normalized to unity during parameter estimation. In this grammar we declare stayProb and leaveProb within a pgroup since they describe the two outcomes at each step of creating the alignment: staying at the current nonterminal or moving to a different one.</p>
          <p>(pgroup (stayProb 0.9) (leaveProb 0.1))</p>
          <p>(&amp;foreach-integer nonterm1 (1 numNonterms)</p>
          <p> ;; Each nonterminal has a transition from start</p>
          <p> (transform (from (start)) (to (nonterm1)) (prob (&amp;/1 numNonterms)))</p>
          <p> ;; Each nonterminal can transition to end - we assign this prob 1</p>
          <p> ;; since the alignment length directs when this transition occurs</p>
          <p> (transform (from (nonterm1)) (to ()) (prob 1))</p>
          <p> (&amp;foreach-integer nonterm2 (1 numNonterms)</p>
          <p>  (&amp;if (&amp;eq nonterm1 nonterm2))</p>
          <p>   ;; If nonterm1 =  = nonterm2, this is a self-transition</p>
          <p>   (transform (from (nonterm1)) (to (nonterm2)) (prob stayProb))</p>
          <p>   ;; Otherwise, this is an inter-nonterminal transition</p>
          <p>   ;; with probability changeProb/(numNonterms - 1)</p>
          <p>   (transform (from (nonterm1)) (to (nonterm2))</p>
          <p>   (prob (&amp;/changeProb (&amp;- numNonterms 1))))))</p>
          <p>Lastly, associate each nonterminal with its specially-designed Markov chain for emitted alignment columns:</p>
          <p>(&amp;foreach-integer nonterminal (1 numNonterms)</p>
          <p> (transform (from (nonterminal))(to ((&amp;cat chain_ nonterminal) (&amp;cat nonterminal *))))</p>
          <p> (transform (from ((&amp;cat nonterminal *))) (to (nonterminal))))</p>
        </sec>
        <sec id="s3a4">
          <title>Data-induced repetition</title>
          <p>Models whose symmetric structure depends on the input data are less common in phylogenetic analysis, perhaps because normally their implementation requires creating a new model for each new dataset to be analyzed. XRate allows the user to create models based on different parts of the input data, namely the tree and the alignment, “on the fly” via its macro language. This is accomplished by making use of the tree iterators (e.g. &amp;BRANCHES, &amp;NODES, and &amp;LEAVES) and alignment data (e.g. &amp;COLUMNS) to create nonterminals and/or terminal chains associated with these parts of the input data.</p>
          <p>In their program DLESS, Haussler and colleagues used such an approach in a tree-dependent model to detect lineage-specific selection. Their model used a phylo-HMM with different nonterminals for each tree node, with the substitution rate below this node scaled to reflect gain or loss of functional elements <xref ref-type="bibr" rid="pone.0036898-Siepel1">[26]</xref>. We show a simplified form of their model as a schematic in <xref ref-type="fig" rid="pone-0036898-g002">Figure 2</xref>, with blue colored branches representing a slowed evolutionary rate.</p>
          <fig id="pone-0036898-g002" position="float">
            <object-id pub-id-type="doi">10.1371/journal.pone.0036898.g002</object-id>
            <label>Figure 2</label>
            <caption>
              <title>A schematic of a DLESS-style phylo-HMM: each node of the tree has its own nonterminal, such that the node-rooted subtree evolves at a slower rate than the rest of the tree.</title>
              <p>Inferring the pattern of hidden nonterminals generating an alignment allows for detecting regions of lineage-specific selection. Expressing this model compactly in XRate 's macro language allows it to be used with any input tree without having to write data-specific code or use external model-generating scripts.</p>
            </caption>
            <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0036898.g002" xlink:type="simple"/>
          </fig>
          <p>Using XRate's macros we can express this model in a compact way just as was done with the PhastCons model. Since both models use a set of nonterminals with their own scaled substitution models, we need simply to replace the integer-based loop (&amp;foreach-integer nonterminal (1 numNonterms) expression) with the tree-based loop (&amp;foreach-node state expression) to create a nonterminal for each node in the tree. Then, define each node-specific chain as a <italic>hybrid chain</italic>, such that the chain associated with tree node <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e023" xlink:type="simple"/></inline-formula> has all the branches below node <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e024" xlink:type="simple"/></inline-formula> scaled to reflect heightened selective pressure. Hybrid chains, substitution processes which vary across the tree, are discussed briefly in the section on “Recent enhancements to XRate”, and the details of their specification is thoroughly covered in the XRate format documentation, available here: <ext-link ext-link-type="uri" xlink:href="http://biowiki.org/XrateFormat" xlink:type="simple">http://biowiki.org/XrateFormat</ext-link>. A minimal working form of the DLESS-style grammar included in <xref ref-type="supplementary-material" rid="pone.0036898.s001">Text S1</xref>.</p>
        </sec>
        <sec id="s3a5">
          <title>A repetitively-structured codon model specified using Scheme functions</title>
          <p>While XRate's macro language is very flexible, there are some relatively common models that are difficult to express within the language's constraints. For example, a Nielsen-Yang codon matrix incorporating transition bias and selection has nearly 4,000 entries whose rates are determined by the following criteria:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0036898.e025" xlink:type="simple"/></disp-formula>This sort of Markov chain is difficult to express in XRate's macro language since its entries are determined by aspects of the codons (synonymous changes and transitions/transversions) which in turn depend on knowledge of the properties of nucleotides and codons that would have to be hard-coded directly into the loops and conditionals afforded by XRate's macros. The conditions on the right side of the above equation are better framed as values returned from a function: given a pair of codons, the function returns the “type” of difference between them, which in turn determines the rate of substitution between the two codons.</p>
        </sec>
        <sec id="s3a6">
          <title>Scheme extensions</title>
          <p>It is this sort of situation which motivates extensions to XRate that are more general-purpose than the simple macros described up to this point. There are several valid choices for the programming language that can be used to implement such extensions. For example, a chain such as <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e026" xlink:type="simple"/></inline-formula> can be generated fairly easily by way of a Perl or Python script tailored to generate XRate grammar code. While this is a convenient scripting mechanism for many users (and is perfectly possible with XRate), it tends to lead to an awkward mix of code and embedded data (i.e. snippets of grammar-formatting text). This obscures both the generating script and the final generated grammar file (the former due to the code/data mix, and the latter due to sheer size).</p>
          <p>Another choice of programming language for implementing XRate extensions, which suffers slightly less from these limitations, is Scheme. As XRate 's macro language is based on Lisp (the parent language to Scheme), the syntaxes are very similar, so the “extension” blends naturally with the surrounding XRate grammar file. Scheme is inherently functional and is also “safe” (in that it has garbage collection). Lastly, data and code have equivalent formats in Scheme, enabling the sort of code/data mingling outlined above.</p>
          <p>To implement the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e027" xlink:type="simple"/></inline-formula> chain in XRate, we can use the XRate Scheme standard library (found in dart/scheme/xrate-stdlib.scm). This standard library implements all the necessary functions to define the Nielsen-Yang model, with the genetic code implemented as a Scheme association list (facilitating easy substitution of alternate genetic codes, such as the mitochondrial code) as well as a wrapper function to initialize the entire model.</p>
          <p>Without stepping through every detail of the Scheme implementation of the Nielsen-Yang model in the XRate standard library, we will simply note that this implementation (the Nielsen-Yang model on a DNA alphabet) is available via the following XRate code (the include path to dart/scheme is searched by default by the Scheme function load-from-path):</p>
          <p>(&amp;scheme</p>
          <p> (load-from-path “xrate-stdlib.scm”)</p>
          <p> xrate-dna-alphabet</p>
          <p> (xrate-NY-grammar))</p>
          <p>Note that xrate-dna-alphabet is a simple variable, but xrate-NY-grammar is a function and is therefore wrapped in parentheses (as per the syntax of calling a function in Scheme). The reason that xrate-NY-grammar is a function is so that the user can optionally redefine the genetic code, which (as noted above) is stored as a Scheme association list, in the variable codon-translation-table (the standard library code can be examined for details).</p>
        </sec>
        <sec id="s3a7">
          <title>A macro-heavy grammar for RNA structures in protein-coding exons</title>
          <p>As a final example of the possibilities that XRate's new model-specification features enable, we present a new grammar for predicting RNA structures which overlap protein-coding regions. XDecoder is based closely on the RNADecoder grammar first developed by Pederson and colleagues <xref ref-type="bibr" rid="pone.0036898-Pedersen1">[27]</xref>. This grammar is designed to detect phylogenetic evidence of conserved RNA structures, while also incorporating the evolutionary signals brought on by selection at the amino-acid level. In eukaryotes, RNA structure overlapping protein coding sequence is not yet well-known, but in viral genomes this is a common phenomenon due to constraints on genome size acting on many virus families. XDecoder is available as an XRate grammar, linked here: <ext-link ext-link-type="uri" xlink:href="http://biowiki.org/XratePaper2011" xlink:type="simple">http://biowiki.org/XratePaper2011</ext-link>.</p>
        </sec>
        <sec id="s3a8">
          <title>Motivation for implementation</title>
          <p>Our endeavor to re-implement the RNADecoder grammar was based both on practical and methodological reasons. The original RNADecoder code is no longer maintained, but performs well on published viral datasets <xref ref-type="bibr" rid="pone.0036898-Watts1">[28]</xref>. Running RNADecoder on an alignment of full viral genomes is quite involved: the alignment must first be split up into appropriately-sized chunks (300 columns), converted to COL format <xref ref-type="bibr" rid="pone.0036898-Col1">[29]</xref>, and linked to a tree in a special XML file which directs the analysis. The grammar and its parameters, also stored in an XML format, are difficult to read and interpret. RNADecoder attains remarkably higher specificity in genome-wide scans as compared to protein-naive prediction programs like PFOLD <xref ref-type="bibr" rid="pone.0036898-Knudsen2">[15]</xref> or MFOLD <xref ref-type="bibr" rid="pone.0036898-Zuker1">[30]</xref>.</p>
        </sec>
        <sec id="s3a9">
          <title>Using XDecoder</title>
          <p>We developed our own variant of the RNADecoder model as an XRate grammar, called XDecoder. This would have been a protracted task without XRate's macro capabilities: the expanded grammar is nearly 4,000 lines of code. Using XRate's macros, the main grammar (excluding the pre-estimated dinucleotide Markov chain) is only 100 lines of macro code. Starting with an alignment of full-length <italic>poliovirus</italic> genomes, annotated with reading frames, an analysis can be run with a single simple command:</p>
          <p>xrate -g XDecoder.eg −l 300 -wig polio.wig polio.stk &gt; polio_annotated.stk</p>
          <p>This runs XRate with the XDecoder grammar on the Stockholm-format alignment polio.stk, allowing no more than 300 positions between paired columns, creating the wiggle file polio.wig, annotating the original alignment with maximum likelihood secondary structure and rate class indicators, and writing the annotated alignment to the the file polio_annotated.stk.</p>
          <p>Each analysis with RNADecoder requires an XML file to coordinate the alignment and tree as well as direct parts of the analysis (training and annotation). XRate reads Stockholm format alignments which natively allows for alignment-tree association, enabling simple batch processing of many alignments. The grammar can be run on arbitrarily long alignments, provided a suitable maximum pair length is specified via the −l N argument. This prevents XRate from considering any pairing whose columns are more than N positions apart, effectively limiting both the memory usage and runtime.</p>
          <p>Training the grammar's parameters, which may be necessary for running the grammar on significantly different datasets, is also accomplished with a single command:</p>
          <p>xrate -g XDecoder.eg −l 300 -t XDecoder.trained.eg polio.stk</p>
          <p>The results of an analysis using XDecoder are shown in <xref ref-type="fig" rid="pone-0036898-g003">Figure 3</xref>, together with gene and RNA structure annotations. Also shown are three related analyses (all done using XRate grammars): PhastCons conservation, coding potential, and pairing probabilities computed using PFOLD. These three separate analyses reflect the signals that XDecoder must tease apart in order to reliably predict RNA structures. DNA-level conservation could be due to protein-coding constraints, regional rate variation, pressure to maintain a particular RNA structure, or a combination of all three. Using codon-position rate multipliers, multiple rate classes, and a secondary structure model, XDecoder unifies all of these signals in a single phylogenetic model, resulting in the highly-specific predictions shown at the top of <xref ref-type="fig" rid="pone-0036898-g003">Figure 3</xref>. The full JBrowse instance is provided as a demo at <ext-link ext-link-type="uri" xlink:href="http://jbrowse.org/poliovirus-xrate-demo-by-oscar-westesson/" xlink:type="simple">http://jbrowse.org/poliovirus-xrate-demo-by-oscar-westesson/</ext-link>.</p>
          <fig id="pone-0036898-g003" position="float">
            <object-id pub-id-type="doi">10.1371/journal.pone.0036898.g003</object-id>
            <label>Figure 3</label>
            <caption>
              <title>Data from several XRate analyses, shown alongside genes (A) and known RNA structures (B) in <italic>poliovirus</italic>.</title>
              <p>XDecoder (<bold>C</bold>) recovers all known structures with high posterior probability and predicts a promising target for experimental probing (region 6800–7100). XDecoder was run on an alignment of 27 <italic>poliovirus</italic> sequences with the results visualized as a track in JBrowse <xref ref-type="bibr" rid="pone.0036898-Skinner1">[32]</xref> via a wiggle file. Alongside XDecoder probabilities are the three signals which XDecoder aims to disentangle: (<bold>D</bold>) conservation, (<bold>E</bold>) coding potential, and (<bold>F</bold>) RNA structure. Paradoxically, the CRE and RNase-L inhibition elements show both conservation and coding sequence preservation, whereas PFOLD's predictions show only a slight increase in probability density around the known structures. XDecoder is the only grammar which returns predictions of reasonable specificity. The full JBrowse instance is included as Text S 2.</p>
            </caption>
            <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0036898.g003" xlink:type="simple"/>
          </fig>
        </sec>
      </sec>
      <sec id="s3b">
        <title>Recent enhancements to XRate</title>
        <sec id="s3b1">
          <title>Lineage-specific models</title>
          <p>All Markov chains in phylo-grammars describe the evolution of characters starting at the root and ending at the tips of the tree. In lineage-specific models, or <italic>hybrid chains</italic> in XRate terminology, the requirement that all branches share the same substitution process is relaxed. Phylogenetic analysis is often used to detect a departure from a “null model” representing some typical evolutionary pattern. Standard applications of HMMs and SCFGs focus on modeling this departure on the alignment level, enabling different columns of the alignment to show different patterns of evolution. Using hybrid chains, users can explicitly model differences in evolution across parts of the tree. By combining a hybrid chain with grammar nonterminals, this could be used to detect alignment regions (i.e. subsets of the set of all sites) which display unusually high (or low) mutation rates in a particular part of the tree, such as in the DLESS model described in the section on “Data-induced repetition”. The details of specifying such models are contained within the XRate format documentation, at <ext-link ext-link-type="uri" xlink:href="http://biowiki.org/XrateFormat" xlink:type="simple">http://biowiki.org/XrateFormat</ext-link>.</p>
        </sec>
        <sec id="s3b2">
          <title>Ancestral sequence reconstruction</title>
          <p>A phylo-grammar is a generative model: it generates a hidden parse tree, then further generates observed data conditional on that parse tree. The observed data here is an alignment of sequences; the hidden parse tree describes which alignment columns are to be generated by the evolutionary models associated with which grammar nonterminals. Inference involves reversing the generative process: reconstructing the hidden parse structure and evolutionary trajectories that explain the alignment.</p>
          <p>The original version of XRate was focused on reconstructing the parse tree, for the purposes of annotating hidden structures such as gene boundaries or conserved regions. A newly-implemented feature in XRate allows an additional feature: reconstruction of ancestral sequences. This functionality is already implicit in the phylogenetic model: no additional modification to the grammar is necessary to enable reconstruction. The user can ask XRate to return the most probable ancestral sequence at each internal node, or the entire posterior distribution over such sequences, via the -ar and -arpp command-line options. Since XRate does marginal state reconstruction, the character with the highest posterior probability returned by the -arpp option will always correspond to the single character returned by the -ar option. Ancestral sequence reconstruction can be used to answer paleogenetic questions: what did the sequence of the ancestor to all of clade <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0036898.e028" xlink:type="simple"/></inline-formula> look like? Similarly, evolutionary events such as particular substitutions or the gain or loss of function (also called trait evolution) can be pinpointed to particular branches.</p>
        </sec>
        <sec id="s3b3">
          <title>Direct output of GFF and Wiggle annotations</title>
          <p>XRate allows parse annotations to be written out directly in common bioinformatics file formats: GFF (a format for specifying co-ordinates of genomic features) <xref ref-type="bibr" rid="pone.0036898-GFF1">[22]</xref> and WIG (a per-base format for quantitative data) <xref ref-type="bibr" rid="pone.0036898-Wiggle1">[31]</xref>.</p>
          <p>This allows a direct link between XRate and visualization tools such as JBrowse <xref ref-type="bibr" rid="pone.0036898-Skinner1">[32]</xref>, GBrowse <xref ref-type="bibr" rid="pone.0036898-Stein1">[33]</xref>, the UCSC Genome Browser <xref ref-type="bibr" rid="pone.0036898-Kent1">[34]</xref>,and Galaxy <xref ref-type="bibr" rid="pone.0036898-Goecks1">[35]</xref>, allowing the results of different analyses to be displayed next to one another and/or processed in a unified framework.</p>
        </sec>
        <sec id="s3b4">
          <title>GFF: Discrete genomic features</title>
          <p>GFF is a format oriented towards storing genomic features using 9 tab-delimited fields: each line represents a separate feature, with each field storing a particular aspect of the feature (e.g. identifier, start, end, etc). With XRate, a common application is using GFF to annotate an alignment with features corresponding to grammar nonterminals. For instance, using a gene-prediction grammar one could store the predicted start and end points of genes together with a confidence measure. Similarly, predicted RNA base pairs could be represented in GFF as one feature per pair, with start and end positions indicating the paired positions.</p>
        </sec>
        <sec id="s3b5">
          <title>WIG: Quantitative values for each column(s)</title>
          <p>Wiggle format stores a quantitative value for a single or group of positions. This can be especially useful to summarize a large number of possibilities as a single representative value. For instance, when predicting regions of structured RNA, XRate may sum over many thousands of possible structures. We can summarize the model's results with the posterior probability that each column is involved in a base-pairing interaction.</p>
        </sec>
      </sec>
      <sec id="s3c">
        <title>The Dart Scheme (Darts) interpreter</title>
        <p>Another way to use XRate, instead of running it from the command line, is to call it from the Scheme interpreter (included in DART). The compiled interpreter executable is named “darts” (for “DART Scheme”). This offers a simple yet powerful way to create parameter-fitting and genome annotation workflows. For example, a user could train a grammar on a set of alignments, then use the resulting grammar to annotate a set of test alignments.</p>
        <p>Darts, in common with the Scheme interpreter used in XRate grammars, is implemented using Guile (GNU's Ubiquitous Intelligent Language for Extension: <ext-link ext-link-type="uri" xlink:href="http://www.gnu.org/software/guile/guile.html" xlink:type="simple">http://www.gnu.org/software/guile/guile.html</ext-link>). Certain commonly-encountered bioinformatics objects, serializable via standard file formats and implemented as C++ classes within XRate, are exposed using Guile's “small object” (smob) mechanism. Currently, these types include Newick-format trees and Stockholm-format alignments. API calls are provided to construct these “smobs” by parsing strings (or files) in the appropriate format. The smobs may then be passed directly as parameters to XRate API calls, or may be “unpacked” into Scheme data structures for individual element access. Guile encourages sparing use of smobs; consequently, smobs are used within Darts exclusively to implement bioinformatic objects that already have a broadly-used file format (Stockholm alignments and Newick trees). In contrast, formats that are newly-introduced by XRate (grammars, alphabets and so forth) are all based on S-expressions, and so may be represented directly as native Scheme data structures.</p>
        <p>The functions listed in <xref ref-type="supplementary-material" rid="pone.0036898.s002">Text S2</xref> provide an interface between Scheme and XRate . Together with the functions in the XRate -scheme standard library and Scheme's native functional scripting abilities, a broad array of models and/or workflows are possible. For instance, one could estimate several sets of parameters for Nielsen-Yang models using groups of alignments, and then embed each one in a PhastCons-style phylo-HMM, finally using this model to annotate a set of alignments. While this and other workflows could be accomplished in an external framework (e.g. Make, Galaxy <xref ref-type="bibr" rid="pone.0036898-Goecks1">[35]</xref>), Darts provides an alternate way to script XRate tasks using the same language that is used to construct the grammars.</p>
      </sec>
    </sec>
    <sec id="s4">
      <title>Supporting Information</title>
      <supplementary-material id="pone.0036898.s001" mimetype="application/zip" position="float" xlink:href="info:doi/10.1371/journal.pone.0036898.s001" xlink:type="simple">
        <label>Text S1</label>
        <caption>
          <p>contains example grammars referred to in the text, as well as small and large test Stockholm alignments. The alignment of <italic>poliovirus</italic> genomes along with the grammars used to produce <xref ref-type="fig" rid="pone-0036898-g003">Figure 3</xref> are also included along with a Makefile indicating how the data was analyzed. Typing make help in the directory containing the Makefile will display the demonstrations available to users.</p>
          <p>(ZIP)</p>
        </caption>
      </supplementary-material>
      <supplementary-material id="pone.0036898.s002" mimetype="application/pdf" position="float" xlink:href="info:doi/10.1371/journal.pone.0036898.s002" xlink:type="simple">
        <label>Text S2</label>
        <caption>
          <p>contains tables describing the Scheme- XRate functions available in Darts.</p>
          <p>(PDF)</p>
        </caption>
      </supplementary-material>
      <supplementary-material id="pone.0036898.s003" mimetype="application/pdf" position="float" xlink:href="info:doi/10.1371/journal.pone.0036898.s003" xlink:type="simple">
        <label>Text S3</label>
        <caption>
          <p>contains a glossary of XRate terminology.</p>
          <p>(PDF)</p>
        </caption>
      </supplementary-material>
    </sec>
  </body>
  <back>
    <ref-list>
      <title>References</title>
      <ref id="pone.0036898-Jukes1">
        <label>1</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Jukes</surname><given-names>TH</given-names></name><name name-style="western"><surname>Cantor</surname><given-names>C</given-names></name></person-group>             <year>1969</year>             <article-title>Evolution of protein molecules.</article-title>             <source>Mammalian Protein Metabolism</source>             <publisher-loc>New York</publisher-loc>             <publisher-name>Academic Press</publisher-name>             <fpage>21</fpage>             <lpage>132</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Kimura1">
        <label>2</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Kimura</surname><given-names>M</given-names></name></person-group>             <year>1980</year>             <article-title>A simple method for estimating evolutionary rates of base substitutions through comparative studies of nucleotide sequences.</article-title>             <source>Journal of Molecular Evolution</source>             <volume>16</volume>             <fpage>111</fpage>             <lpage>120</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Hasegawa1">
        <label>3</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Hasegawa</surname><given-names>M</given-names></name><name name-style="western"><surname>Kishino</surname><given-names>H</given-names></name><name name-style="western"><surname>Yano</surname><given-names>T</given-names></name></person-group>             <year>1985</year>             <article-title>Dating the human-ape splitting by a molecular clock of mitochondrial DNA.</article-title>             <source>Journal of Molecular Evolution</source>             <volume>22</volume>             <fpage>160</fpage>             <lpage>174</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Felsenstein1">
        <label>4</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Felsenstein</surname><given-names>J</given-names></name></person-group>             <year>1981</year>             <article-title>Evolutionary trees from DNA sequences: a maximum likelihood approach.</article-title>             <source>Journal of Molecular Evolution</source>             <volume>17</volume>             <fpage>368</fpage>             <lpage>376</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Meyer1">
        <label>5</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Meyer</surname><given-names>IM</given-names></name><name name-style="western"><surname>Durbin</surname><given-names>R</given-names></name></person-group>             <year>2004</year>             <article-title>Gene structure conservation aids similarity based gene prediction.</article-title>             <source>Nucleic Acids Research</source>             <volume>32</volume>             <fpage>776</fpage>             <lpage>783</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Eddy1">
        <label>6</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Eddy</surname><given-names>SR</given-names></name></person-group>             <year>1998</year>             <article-title>Profile hidden Markov models.</article-title>             <source>Bioinformatics</source>             <volume>14</volume>             <fpage>755</fpage>             <lpage>763</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Knudsen1">
        <label>7</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Knudsen</surname><given-names>B</given-names></name><name name-style="western"><surname>Hein</surname><given-names>J</given-names></name></person-group>             <year>1999</year>             <article-title>RNA secondary structure prediction using stochastic context-free grammars and evolutionary history.</article-title>             <source>Bioinformatics</source>             <volume>15</volume>             <fpage>446</fpage>             <lpage>454</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Garber1">
        <label>8</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Garber</surname><given-names>M</given-names></name><name name-style="western"><surname>Guttman</surname><given-names>M</given-names></name><name name-style="western"><surname>Clamp</surname><given-names>M</given-names></name><name name-style="western"><surname>Zody</surname><given-names>M</given-names></name><name name-style="western"><surname>Friedman</surname><given-names>N</given-names></name><etal/></person-group>             <year>2009</year>             <article-title>Identifying novel constrained elements by exploiting biased substitution patterns.</article-title>             <source>Bioinformatics</source>          </element-citation>
      </ref>
      <ref id="pone.0036898-Klosterman1">
        <label>9</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Klosterman</surname><given-names>PS</given-names></name><name name-style="western"><surname>Uzilov</surname><given-names>AV</given-names></name><name name-style="western"><surname>Bendana</surname><given-names>YR</given-names></name><name name-style="western"><surname>Bradley</surname><given-names>RK</given-names></name><name name-style="western"><surname>Chao</surname><given-names>S</given-names></name><etal/></person-group>             <year>2006</year>             <article-title>XRate: a fast prototyping, training and annotation tool for phylo-grammars.</article-title>             <source>BMC Bioinformatics</source>             <volume>7</volume>          </element-citation>
      </ref>
      <ref id="pone.0036898-Slater1">
        <label>10</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Slater</surname><given-names>GSC</given-names></name><name name-style="western"><surname>Birney</surname><given-names>E</given-names></name></person-group>             <year>2005</year>             <article-title>Automated generation of heuristics for biological sequence comparison.</article-title>             <source>BMC Bioinformatics</source>             <volume>6</volume>             <fpage>31</fpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Birney1">
        <label>11</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Birney</surname><given-names>E</given-names></name><name name-style="western"><surname>Durbin</surname><given-names>R</given-names></name></person-group>             <year>1997</year>             <article-title>Dynamite: a exible code generating language for dynamic programming methods used in sequence comparison.</article-title>             <person-group person-group-type="editor"><name name-style="western"><surname>Gaasterland</surname><given-names>T</given-names></name><name name-style="western"><surname>Karp</surname><given-names>P</given-names></name><name name-style="western"><surname>Karplus</surname><given-names>K</given-names></name><name name-style="western"><surname>Ouzounis</surname><given-names>C</given-names></name><name name-style="western"><surname>Sander</surname><given-names>C</given-names></name><etal/></person-group>             <source>Proceedings of the Fifth International Conference on Intelligent Systems for Molecular Biology</source>             <publisher-loc>Menlo Park, CA</publisher-loc>             <publisher-name>AAAI Press</publisher-name>             <fpage>56</fpage>             <lpage>64</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Lunter1">
        <label>12</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Lunter</surname><given-names>G</given-names></name></person-group>             <year>2007</year>             <article-title>HMMoC–a compiler for hidden Markov models.</article-title>             <source>Bioinformatics</source>             <volume>23</volume>             <fpage>2485</fpage>             <lpage>2487</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Drummond1">
        <label>13</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Drummond</surname><given-names>AJ</given-names></name><name name-style="western"><surname>Rambaut</surname><given-names>A</given-names></name></person-group>             <year>2007</year>             <article-title>BEAST: Bayesian evolutionary analysis by sampling trees.</article-title>             <source>BMC Evolutionary Biology</source>             <volume>7</volume>          </element-citation>
      </ref>
      <ref id="pone.0036898-Yang1">
        <label>14</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Yang</surname><given-names>Z</given-names></name><name name-style="western"><surname>Nielsen</surname><given-names>R</given-names></name><name name-style="western"><surname>Goldman</surname><given-names>N</given-names></name><name name-style="western"><surname>Pedersen</surname><given-names>AM</given-names></name></person-group>             <year>2000</year>             <article-title>Codon-substitution models for heterogeneous selection pressure at amino acid sites.</article-title>             <source>Genetics</source>             <volume>155</volume>             <fpage>432</fpage>             <lpage>449</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Knudsen2">
        <label>15</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Knudsen</surname><given-names>B</given-names></name><name name-style="western"><surname>Hein</surname><given-names>J</given-names></name></person-group>             <year>2003</year>             <article-title>Pfold: RNA secondary structure prediction using stochastic context-free grammars.</article-title>             <source>Nucleic Acids Research</source>             <volume>31</volume>             <fpage>3423</fpage>             <lpage>3428</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Heger1">
        <label>16</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Heger</surname><given-names>A</given-names></name><name name-style="western"><surname>Ponting</surname><given-names>CP</given-names></name><name name-style="western"><surname>Holmes</surname><given-names>I</given-names></name></person-group>             <year>2009</year>             <article-title>Accurate estimation of gene evolutionary rates using XRATE, with an application to transmembrane proteins.</article-title>             <source>Molecular Biology and Evolution</source>             <volume>26</volume>             <fpage>1715</fpage>             <lpage>1721</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Ayres1">
        <label>17</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Ayres</surname><given-names>D</given-names></name><name name-style="western"><surname>Darling</surname><given-names>A</given-names></name><name name-style="western"><surname>Zwickl</surname><given-names>D</given-names></name><name name-style="western"><surname>Beerli</surname><given-names>P</given-names></name><name name-style="western"><surname>Holder</surname><given-names>M</given-names></name><etal/></person-group>             <year>2011</year>             <article-title>Beagle: an application programming interface and high-performance computing library for statistical phylogenetics.</article-title>             <source>Systematic Biology</source>          </element-citation>
      </ref>
      <ref id="pone.0036898-Bradley1">
        <label>18</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Bradley</surname><given-names>RK</given-names></name><name name-style="western"><surname>Uzilov</surname><given-names>AV</given-names></name><name name-style="western"><surname>Skinner</surname><given-names>ME</given-names></name><name name-style="western"><surname>Bendana</surname><given-names>YR</given-names></name><name name-style="western"><surname>Barquist</surname><given-names>L</given-names></name><etal/></person-group>             <year>2009</year>             <article-title>Evolutionary modeling and prediction of non-coding RNAs in Drosophila.</article-title>             <source>PLoS ONE</source>             <volume>4</volume>             <fpage>e6478</fpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Varadarajan1">
        <label>19</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Varadarajan</surname><given-names>A</given-names></name><name name-style="western"><surname>Bradley</surname><given-names>RK</given-names></name><name name-style="western"><surname>Holmes</surname><given-names>I</given-names></name></person-group>             <year>2008</year>             <article-title>Tools for simulating evolution of aligned genomic regions with integrated parameter estimation.</article-title>             <source>Genome Biology</source>             <volume>9</volume>          </element-citation>
      </ref>
      <ref id="pone.0036898-The1">
        <label>20</label>
        <element-citation publication-type="other" xlink:type="simple">             <article-title>The Stockholm _le format.</article-title>             <comment>Available: <ext-link ext-link-type="uri" xlink:href="http://sonnhammer.sbc.su.se/Stockholm.html" xlink:type="simple">http://sonnhammer.sbc.su.se/Stockholm.html</ext-link>. Accessed 4 May 2012</comment>          </element-citation>
      </ref>
      <ref id="pone.0036898-The2">
        <label>21</label>
        <element-citation publication-type="other" xlink:type="simple">             <article-title>The Newick file format.</article-title>             <comment>Available: <ext-link ext-link-type="uri" xlink:href="http://evolution.genetics.washington.edu/phylip/newicktree.html" xlink:type="simple">http://evolution.genetics.washington.edu/phylip/newicktree.html</ext-link>. Accessed 4 May 2012</comment>          </element-citation>
      </ref>
      <ref id="pone.0036898-GFF1">
        <label>22</label>
        <element-citation publication-type="other" xlink:type="simple">             <article-title>GFF: an exchange format for gene-finding features.</article-title>             <comment>Available: <ext-link ext-link-type="uri" xlink:href="http://www.sanger.ac.uk/resources/software/gff/" xlink:type="simple">http://www.sanger.ac.uk/resources/software/gff/</ext-link>. Accessed 4 May 2012</comment>          </element-citation>
      </ref>
      <ref id="pone.0036898-Saitou1">
        <label>23</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Saitou</surname><given-names>N</given-names></name><name name-style="western"><surname>Nei</surname><given-names>M</given-names></name></person-group>             <year>1987</year>             <article-title>The neighbor-joining method: a new method for reconstructing phylogenetic trees.</article-title>             <source>Molecular Biology and Evolution</source>             <volume>4</volume>             <fpage>406</fpage>             <lpage>425</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Searls1">
        <label>24</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Searls</surname><given-names>DB</given-names></name><name name-style="western"><surname>Murphy</surname><given-names>KP</given-names></name></person-group>             <year>1995</year>             <article-title>Automata-theoretic models of mutation and alignment.</article-title>             <person-group person-group-type="editor"><name name-style="western"><surname>Rawlings</surname><given-names>C</given-names></name><name name-style="western"><surname>Clark</surname><given-names>D</given-names></name><name name-style="western"><surname>Altman</surname><given-names>R</given-names></name><name name-style="western"><surname>Hunter</surname><given-names>L</given-names></name><name name-style="western"><surname>Lengauer</surname><given-names>T</given-names></name><etal/></person-group>             <source>Proceedings of the Third International Conference on Intelligent Systems for Molecular Biology</source>             <publisher-loc>Menlo Park, CA</publisher-loc>             <publisher-name>AAAI Press</publisher-name>             <fpage>341</fpage>             <lpage>349</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Penn1">
        <label>25</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Penn</surname><given-names>O</given-names></name><name name-style="western"><surname>Stern</surname><given-names>A</given-names></name><name name-style="western"><surname>Rubinstein</surname><given-names>ND</given-names></name><name name-style="western"><surname>Dutheil</surname><given-names>J</given-names></name><name name-style="western"><surname>Bacharach</surname><given-names>E</given-names></name><etal/></person-group>             <year>2008</year>             <article-title>Evolutionary modeling of rate shifts reveals specificity determinants in hiv-1 subtypes.</article-title>             <source>PLoS Computational Biology</source>             <volume>4</volume>             <fpage>e1000214</fpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Siepel1">
        <label>26</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Siepel</surname><given-names>A</given-names></name><name name-style="western"><surname>Bejerano</surname><given-names>G</given-names></name><name name-style="western"><surname>Pedersen</surname><given-names>JS</given-names></name><name name-style="western"><surname>Hinrichs</surname><given-names>AS</given-names></name><name name-style="western"><surname>Hou</surname><given-names>M</given-names></name><etal/></person-group>             <year>2005</year>             <article-title>Evolutionarily conserved elements in vertebrate, insect, worm, and yeast genomes.</article-title>             <source>Genome Research</source>             <volume>15</volume>             <fpage>1034</fpage>             <lpage>1050</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Pedersen1">
        <label>27</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Pedersen</surname><given-names>JS</given-names></name><name name-style="western"><surname>Meyer</surname><given-names>IM</given-names></name><name name-style="western"><surname>Forsberg</surname><given-names>R</given-names></name><name name-style="western"><surname>Simmonds</surname><given-names>P</given-names></name><name name-style="western"><surname>Hein</surname><given-names>J</given-names></name></person-group>             <year>2004</year>             <article-title>A comparative method for finding and folding RNA secondary structures within protein-coding regions.</article-title>             <source>Nucleic Acids Research</source>             <volume>32</volume>             <fpage>4925</fpage>             <lpage>4923</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Watts1">
        <label>28</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Watts</surname><given-names>J</given-names></name><name name-style="western"><surname>Dang</surname><given-names>K</given-names></name><name name-style="western"><surname>Gorelick</surname><given-names>R</given-names></name><name name-style="western"><surname>Leonard</surname><given-names>C</given-names></name><name name-style="western"><surname>Bess</surname><given-names>J</given-names></name><etal/></person-group>             <year>2009</year>             <article-title>Architecture and secondary structure of an entire hiv-1 rna genome.</article-title>             <source>Nature</source>          </element-citation>
      </ref>
      <ref id="pone.0036898-Col1">
        <label>29</label>
        <element-citation publication-type="other" xlink:type="simple">             <article-title>Col format.</article-title>             <comment>Available: <ext-link ext-link-type="uri" xlink:href="http://colformat.kvl.dk/" xlink:type="simple">http://colformat.kvl.dk/</ext-link>. Accessed 4 May 2012</comment>          </element-citation>
      </ref>
      <ref id="pone.0036898-Zuker1">
        <label>30</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Zuker</surname><given-names>M</given-names></name></person-group>             <year>1989</year>             <article-title>Computer prediction of RNA structure.</article-title>             <source>Methods in Enzymology</source>             <volume>180</volume>             <fpage>262</fpage>             <lpage>288</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Wiggle1">
        <label>31</label>
        <element-citation publication-type="other" xlink:type="simple">             <article-title>Wiggle track format.</article-title>             <comment><ext-link ext-link-type="uri" xlink:href="https://cgwb.nci.nih.gov/goldenPath/help/wiggle.html" xlink:type="simple">https://cgwb.nci.nih.gov/goldenPath/help/wiggle.html</ext-link>. Accessed : 4 May 2012</comment>          </element-citation>
      </ref>
      <ref id="pone.0036898-Skinner1">
        <label>32</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Skinner</surname><given-names>ME</given-names></name><name name-style="western"><surname>Uzilov</surname><given-names>AV</given-names></name><name name-style="western"><surname>Stein</surname><given-names>LD</given-names></name><name name-style="western"><surname>Mungall</surname><given-names>CJ</given-names></name><name name-style="western"><surname>Holmes</surname><given-names>IH</given-names></name></person-group>             <year>2009</year>             <article-title>JBrowse: a next-generation genome browser.</article-title>             <source>Genome Res</source>             <volume>19</volume>             <fpage>1630</fpage>             <lpage>1638</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Stein1">
        <label>33</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Stein</surname><given-names>L</given-names></name><name name-style="western"><surname>Mungall</surname><given-names>C</given-names></name><name name-style="western"><surname>Shu</surname><given-names>S</given-names></name><name name-style="western"><surname>Caudy</surname><given-names>M</given-names></name><name name-style="western"><surname>Mangone</surname><given-names>M</given-names></name><etal/></person-group>             <year>2002</year>             <article-title>The generic genome browser: a building block for a model organism system database.</article-title>             <source>Genome Research</source>             <volume>12</volume>             <fpage>1599</fpage>             <lpage>1610</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Kent1">
        <label>34</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Kent</surname><given-names>WJ</given-names></name><name name-style="western"><surname>Sugnet</surname><given-names>CW</given-names></name><name name-style="western"><surname>Furey</surname><given-names>TS</given-names></name><name name-style="western"><surname>Roskin</surname><given-names>KM</given-names></name><name name-style="western"><surname>Pringle</surname><given-names>TH</given-names></name><etal/></person-group>             <year>2003</year>             <article-title>The human genome browser at UCSC.</article-title>             <source>Genome Research</source>             <volume>12</volume>             <fpage>996</fpage>             <lpage>1006</lpage>          </element-citation>
      </ref>
      <ref id="pone.0036898-Goecks1">
        <label>35</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Goecks</surname><given-names>J</given-names></name><name name-style="western"><surname>Nekrutenko</surname><given-names>A</given-names></name><name name-style="western"><surname>Taylor</surname><given-names>J</given-names></name><name name-style="western"><surname>Afgan</surname><given-names>E</given-names></name><name name-style="western"><surname>Ananda</surname><given-names>G</given-names></name><etal/></person-group>             <year>2010</year>             <article-title>Galaxy: a comprehensive approach for supporting accessible, reproducible, and transparent computational research in the life sciences.</article-title>             <source>Genome Biol</source>             <volume>11</volume>             <fpage>R86</fpage>          </element-citation>
      </ref>
    </ref-list>
    
  </back>
</article>