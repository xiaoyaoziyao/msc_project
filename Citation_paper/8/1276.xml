<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="3.0" xml:lang="EN">
<front>
<journal-meta><journal-id journal-id-type="nlm-ta">PLoS ONE</journal-id><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="pmc">plosone</journal-id><!--===== Grouping journal title elements =====--><journal-title-group><journal-title>PLoS ONE</journal-title></journal-title-group><issn pub-type="epub">1932-6203</issn><publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, USA</publisher-loc></publisher></journal-meta>
<article-meta><article-id pub-id-type="publisher-id">09-PONE-RA-14469R1</article-id><article-id pub-id-type="doi">10.1371/journal.pone.0009490</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group><subj-group subj-group-type="Discipline"><subject>Computational Biology/Macromolecular Sequence Analysis</subject><subject>Evolutionary Biology/Bioinformatics</subject><subject>Molecular Biology/Molecular Evolution</subject></subj-group></article-categories><title-group><article-title>FastTree 2 – Approximately Maximum-Likelihood Trees for Large Alignments</article-title><alt-title alt-title-type="running-head">FastTree 2</alt-title></title-group><contrib-group>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Price</surname><given-names>Morgan N.</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="corresp" rid="cor1"><sup>*</sup></xref></contrib>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Dehal</surname><given-names>Paramvir S.</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Arkin</surname><given-names>Adam P.</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff3"><sup>3</sup></xref></contrib>
</contrib-group><aff id="aff1"><label>1</label><addr-line>Physical Biosciences Division, Lawrence Berkeley National Lab, Berkeley, California, United States of America</addr-line>       </aff><aff id="aff2"><label>2</label><addr-line>Virtual Institute of Microbial Stress and Survival, Lawrence Berkeley National Lab, Berkeley, California, United States of America</addr-line>       </aff><aff id="aff3"><label>3</label><addr-line>Department of Bioengineering, University of California, Berkeley, California, United States of America</addr-line>       </aff><contrib-group>
<contrib contrib-type="editor" xlink:type="simple"><name name-style="western"><surname>Poon</surname><given-names>Art F. Y.</given-names></name>
<role>Editor</role>
<xref ref-type="aff" rid="edit1"/></contrib>
</contrib-group><aff id="edit1">Providence Health Care, Canada</aff><author-notes>
<corresp id="cor1">* E-mail: <email xlink:type="simple">MorganNPrice@yahoo.com</email></corresp>
<fn fn-type="con"><p>Conceived and designed the experiments: MNP PD. Performed the experiments: MNP. Analyzed the data: MNP. Wrote the paper: MNP PD APA.</p></fn>
<fn fn-type="conflict"><p>The authors have declared that no competing interests exist.</p></fn></author-notes><pub-date pub-type="collection"><year>2010</year></pub-date><pub-date pub-type="epub"><day>10</day><month>3</month><year>2010</year></pub-date><volume>5</volume><issue>3</issue><elocation-id>e9490</elocation-id><history>
<date date-type="received"><day>25</day><month>11</month><year>2009</year></date>
<date date-type="accepted"><day>9</day><month>2</month><year>2010</year></date>
</history><!--===== Grouping copyright info into permissions =====--><permissions><copyright-year>2010</copyright-year><copyright-holder>Price et al</copyright-holder><license><license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p></license></permissions><abstract><sec>
<title>Background</title>
<p>We recently described FastTree, a tool for inferring phylogenies for alignments with up to hundreds of thousands of sequences. Here, we describe improvements to FastTree that improve its accuracy without sacrificing scalability.</p>
</sec><sec>
<title>Methodology/Principal Findings</title>
<p>Where FastTree 1 used nearest-neighbor interchanges (NNIs) and the minimum-evolution criterion to improve the tree, FastTree 2 adds minimum-evolution subtree-pruning-regrafting (SPRs) and maximum-likelihood NNIs. FastTree 2 uses heuristics to restrict the search for better trees and estimates a rate of evolution for each site (the “CAT” approximation). Nevertheless, for both simulated and genuine alignments, FastTree 2 is slightly more accurate than a standard implementation of maximum-likelihood NNIs (PhyML 3 with default settings). Although FastTree 2 is not quite as accurate as methods that use maximum-likelihood SPRs, most of the splits that disagree are poorly supported, and for large alignments, FastTree 2 is 100–1,000 times faster. FastTree 2 inferred a topology and likelihood-based local support values for 237,882 distinct 16S ribosomal RNAs on a desktop computer in 22 hours and 5.8 gigabytes of memory.</p>
</sec><sec>
<title>Conclusions/Significance</title>
<p>FastTree 2 allows the inference of maximum-likelihood phylogenies for huge alignments. FastTree 2 is freely available at <ext-link ext-link-type="uri" xlink:href="http://www.microbesonline.org/fasttree" xlink:type="simple">http://www.microbesonline.org/fasttree</ext-link>.</p>
</sec></abstract><funding-group><funding-statement>This work was supported by a grant from the US Department of Energy Genomics: GTL program (DE-AC02-05CH11231). The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement></funding-group><counts><page-count count="10"/></counts></article-meta>
</front>
<body><sec id="s1">
<title>Introduction</title>
<p>Inferring evolutionary relationships, or phylogenies, from families of related DNA or protein sequences is a central method in computational biology. Sequence-based phylogenies are widely used to understand the evolutionary relationships of organisms and to analyze the functions of genes.</p>
<p>The largest gene families already contain tens to hundreds of thousands of representatives, and with the rapid improvements in DNA sequencing, we expect even larger data sets to arrive soon. Large families can be aligned with profile-based methods that scale linearly with the number of sequences (<ext-link ext-link-type="uri" xlink:href="http://hmmer.janelia.org/" xlink:type="simple">http://hmmer.janelia.org/</ext-link>; <xref ref-type="bibr" rid="pone.0009490-Nawrocki1">[1]</xref>). However, most methods for inferring phylogenies from these alignments scale as O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e001" xlink:type="simple"/></inline-formula>) or worse, where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e002" xlink:type="simple"/></inline-formula> is the number of sequences and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e003" xlink:type="simple"/></inline-formula> is the length (width) of the alignment. Thus, inferring phylogenies has become computationally challenging.</p>
<p>We recently described a scalable method for inferring phylogenies, FastTree 1.0 <xref ref-type="bibr" rid="pone.0009490-Price1">[2]</xref>. FastTree 1.0 is based on the “minimum-evolution” principle – it tries to find a topology that minimizes the amount of evolution, or the sum of the branch lengths. FastTree 1.0 uses a heuristic variant of neighbor joining <xref ref-type="bibr" rid="pone.0009490-Saitou1">[3]</xref>, <xref ref-type="bibr" rid="pone.0009490-Studier1">[4]</xref> to quickly find a starting tree and uses nearest-neighbor interchanges (NNIs) to refine the topology. (A nearest-neighbor interchange swaps a node and its neighbor; for example, it might change ((A,B),C,D) to ((A,C),B,D) or ((A,D),B,C).) FastTree implements these operations in O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e004" xlink:type="simple"/></inline-formula>) space, where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e005" xlink:type="simple"/></inline-formula> is the number of characters in the alphabet, by storing profiles of subtrees instead of distances between them. This requires far less memory than storing the pairwise distances, which is necessary for neighbor joining and related approaches. This also allows for heuristics that reduce the theoretical running time to O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e006" xlink:type="simple"/></inline-formula>). (FastTree 1.0 also included some O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e007" xlink:type="simple"/></inline-formula>) steps, but these have since been removed, see <ext-link ext-link-type="uri" xlink:href="http://www.microbesonline.org/fasttree/ChangeLog" xlink:type="simple">http://www.microbesonline.org/fasttree/ChangeLog</ext-link>.) In comparison, computing all pairwise distances, which is required with most minimum-evolution approaches, requires O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e008" xlink:type="simple"/></inline-formula>) time. The main limitation of FastTree 1.0, as compared to other minimum-evolution methods, is that it does not correct distances for multiple substitutions during its initial neighbor joining phase. However, this is more than made up for by the NNIs. In practice, FastTree 1.0 is more accurate than most other minimum-evolution methods, but not as accurate as maximum-likelihood methods <xref ref-type="bibr" rid="pone.0009490-Price1">[2]</xref>.</p>
<p>In the maximum-likelihood (ML) approach, evolution is explicitly modeled with a transition rate matrix, and the tree that best explains the data – the tree with the highest likelihood – is the best tree <xref ref-type="bibr" rid="pone.0009490-Felsenstein1">[5]</xref>. The ML criterion ranks the trees but does not specify how to find a good topology. Because ML phylogenetic inference is NP complete <xref ref-type="bibr" rid="pone.0009490-Roch1">[6]</xref>, no practical method can guarantee that it will find the optimal topology for a large alignment. The most scalable ML methods, such as PhyML and RAxML, begin with a starting tree produced by a faster method, and try to increase the likelihood by optimizing individual branch lengths and performing local rearrangements <xref ref-type="bibr" rid="pone.0009490-Guindon1">[7]</xref>–<xref ref-type="bibr" rid="pone.0009490-Stamatakis1">[9]</xref>. By re-optimizing only a few branch lengths at each move, the cost of considering or performing a move can be reduced to O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e009" xlink:type="simple"/></inline-formula>) time, where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e010" xlink:type="simple"/></inline-formula> is the size of the alphabet. However, in practice, the number of moves grows as roughly O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e011" xlink:type="simple"/></inline-formula>), and the optimization steps are inherently slow because they require numerical solving and iteration. This explains why both PhyML and RAxML can take over a day for just 1,000 protein sequences. Estimating the reliability of the tree with the bootstrap <xref ref-type="bibr" rid="pone.0009490-Felsenstein2">[10]</xref> generally increases the computational requirements another 100-fold (although this can be reduced by reusing computations across replicates <xref ref-type="bibr" rid="pone.0009490-Stamatakis2">[11]</xref>).</p>
<p>Here, we describe FastTree 2, a tool for inferring ML trees for large alignments. Besides constructing an initial tree with neighbor joining and improving it with minimum-evolution NNIs, FastTree 2 uses minimum-evolution subtree-pruning-regrafting (SPRs) <xref ref-type="bibr" rid="pone.0009490-Hordijk1">[8]</xref>, <xref ref-type="bibr" rid="pone.0009490-Desper1">[12]</xref> and ML NNIs to further improve the tree. (In subtree-pruning-regrafting, a subtree is removed from the tree and reinserted elsewhere, e.g., pruning and regrafting C might change ((A,B),(C,D),E) to ((A,(B,C)),D,E).) FastTree 2 uses heuristics to reduce the search space and hence to maintain the scalability of both stages. Another justification for reducing the search space is that intensive tree search often finds small improvements in the tree's length or likelihood, but these changes may not be statistically or biologically significant (e.g., <xref ref-type="bibr" rid="pone.0009490-Nei1">[13]</xref>). Briefly, FastTree's key heuristics are:</p>
<list list-type="bullet"><list-item>
<p>It uses “linear SPRs” to consider just <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e012" xlink:type="simple"/></inline-formula> of the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e013" xlink:type="simple"/></inline-formula> possible SPR moves. At each node, it examines the shortest SPRs first and then extends the most promising candidates.</p>
</list-item><list-item>
<p>It searches for SPR moves for every subtree just twice, instead of iterating until convergence.</p>
</list-item><list-item>
<p>During the ML phase, it limits the ML NNIs to at most <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e014" xlink:type="simple"/></inline-formula> rounds; in practice, it converges before it reaches this limit, but the limit ensures a predictable running time.</p>
</list-item><list-item>
<p>It limits the effort to optimize model parameters and branch lengths.</p>
</list-item><list-item>
<p>It abandons optimization for NNI moves that seem, after partial optimization, to significantly lower the likelihood.</p>
</list-item><list-item>
<p>It does not try to improve parts of the tree that did not improve in recent rounds.</p>
</list-item></list>
<p>To account for the variation in rates across sites, FastTree uses the “CAT” approximation <xref ref-type="bibr" rid="pone.0009490-Stamatakis3">[14]</xref> rather than the standard discrete gamma model with four rates (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e015" xlink:type="simple"/></inline-formula>) <xref ref-type="bibr" rid="pone.0009490-Yang1">[15]</xref>. Some sites evolve much more slowly than others, and the ideal way to account for this is to integrate the likelihood at each site over the (unknown) relative evolutionary rate of that site, using a prior distribution over the relative rates such as a gamma distribution. However, these integrals are analytically intractable and computationally prohibitive. The “<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e016" xlink:type="simple"/></inline-formula>” approach is to use four rate categories to approximate the continuous gamma distribution. However, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e017" xlink:type="simple"/></inline-formula> still requires four times more CPU time and memory than a model with no rate variation across sites. Furthermore, for large alignments, the data tightly constrains the rate at each site. Thus, it is much faster, and just as accurate, to use a good estimate of the rate at each site (CAT) rather than to sum over four potential rates (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e018" xlink:type="simple"/></inline-formula>) <xref ref-type="bibr" rid="pone.0009490-Stamatakis3">[14]</xref>. FastTree selects the most likely rate for each site from among 20 fixed possibilities.</p>
<p>Because of the heuristics, FastTree 2 is not guaranteed to reach a locally optimal likelihood in tree space. However, at each step it does guarantee that the likelihood increases (under the CAT approximation). Thus, FastTree 2 is an approximately-maximum-likelihood method.</p>
<p>We will show that in practice, FastTree 2 is slightly more accurate than a standard implementation of maximum-likelihood NNIs, PhyML 3 with default settings <xref ref-type="bibr" rid="pone.0009490-Guindon2">[16]</xref>, <xref ref-type="bibr" rid="pone.0009490-Guindon3">[17]</xref>. Specifically, in simulations, FastTree 2 recovers a higher proportion of true splits, and on genuine alignments, FastTree 2's topologies tend to have higher likelihoods. FastTree's minimum-evolution SPR moves give it a better starting tree than PhyML's starting tree, which is obtained with BIONJ (a weighted variant of neighbor joining <xref ref-type="bibr" rid="pone.0009490-Gascuel1">[18]</xref>). This more than makes up for FastTree's heuristics, which reduce the intensity of search for ML NNIs but have little effect on accuracy. We also confirm that using the CAT approximation instead of the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e019" xlink:type="simple"/></inline-formula> model (which is itself an approximation of the continuous gamma distribution) has little effect on the quality of the tree.</p>
<p>Although FastTree 2 is significantly less accurate than ML methods that use SPR moves, such as PhyML with slower settings or RAxML, most of the splits that disagree are poorly supported, and FastTree is much faster. FastTree 2 can analyze alignments with tens or hundreds of thousands of sequences in under a day on a desktop computer. For alignments with 500 sequences or more, FastTree 2 is at least 100 times faster than either PhyML 3.0 or RAxML 7.2.1. FastTree 2 is faster than RAxML 7 mostly because of less intensive ML search (NNIs instead of SPRs) and because RAxML 7 optimizes branch lengths under the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e020" xlink:type="simple"/></inline-formula> model. However, FastTree also has a faster starting tree, and it initially increases the likelihood more quickly than RAxML 7 does.</p>
<p>Because of its speed, FastTree 2 is suitable for bootstrapping. However, to provide a quicker estimate of the tree's reliability, FastTree 2 provides local support values based on the Shimodaira-Hasegawa (SH) test <xref ref-type="bibr" rid="pone.0009490-Guindon2">[16]</xref>, <xref ref-type="bibr" rid="pone.0009490-Guindon3">[17]</xref>, <xref ref-type="bibr" rid="pone.0009490-Shimodaira1">[19]</xref>. FastTree 2 should be useful for reconstructing the tree of life and for analyzing the millions of uncharacterized proteins that are being identified by genome sequencing.</p>
</sec><sec id="s2">
<title>Results</title>
<p>We compared FastTree's speed and accuracy to those of PhyML 3.0 and RAxML 7, the most popular maximum-likelihood methods. To measure the quality of the resulting trees, we measured the topological accuracy on simulated alignments and the likelihood on genuine biological alignments.</p>
<sec id="s2a">
<title>Topological Accuracy in Simulations</title>
<p>We tested FastTree on simulated protein alignments with 250 to 5,000 sequences <xref ref-type="bibr" rid="pone.0009490-Price1">[2]</xref>. These simulations were derived from diverse gene families that arise in genome-scale studies (“Collections of Orthologous Groups” or COGs, <xref ref-type="bibr" rid="pone.0009490-Tatusov1">[20]</xref>). The simulations include varying evolutionary rates across sites and include realistic placement of gaps. The simulations are available from the FastTree web site (<ext-link ext-link-type="uri" xlink:href="http://microbesonline.org/fasttree/#Sims" xlink:type="simple">http://microbesonline.org/fasttree/#Sims</ext-link>).</p>
<p>We defined the topological accuracy as the proportion of the splits in the true trees that are recovered by each method. This is the converse of the topological (“Robinson-Foulds”) distance, scaled to range from 0 to 1. As shown in <xref ref-type="table" rid="pone-0009490-t001">Table 1</xref>, FastTree 2 was slightly more accurate than PhyML 3 with default settings (NNI search), and much more accurate than minimum-evolution or parsimony methods, but not as accurate as ML methods that use SPR moves. The differences in accuracy between FastTree 2 and the other methods were statistically significant (all <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e021" xlink:type="simple"/></inline-formula>, paired <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e022" xlink:type="simple"/></inline-formula> tests).</p>
<table-wrap id="pone-0009490-t001" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0009490.t001</object-id><label>Table 1</label><caption>
<title>Topological accuracy of trees inferred from simulated alignments.</title>
</caption><!--===== Grouping alternate versions of objects =====--><alternatives><graphic id="pone-0009490-t001-1" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0009490.t001" xlink:type="simple"/><table><colgroup span="1"><col align="left" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/></colgroup>
<thead>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1">250</td>
<td align="left" colspan="1" rowspan="1">1,250</td>
<td align="left" colspan="1" rowspan="1">5,000</td>
<td align="left" colspan="1" rowspan="1">78,132</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">Method</td>
<td align="left" colspan="1" rowspan="1">a.a.</td>
<td align="left" colspan="1" rowspan="1">a.a.</td>
<td align="left" colspan="1" rowspan="1">a.a.</td>
<td align="left" colspan="1" rowspan="1">nt.</td>
</tr>
</thead>
<tbody>
<tr>
<td align="left" colspan="1" rowspan="1">RAxML 7 (JTT+CAT, SPRs)</td>
<td align="left" colspan="1" rowspan="1">90.5%</td>
<td align="left" colspan="1" rowspan="1">88.4%</td>
<td align="left" colspan="1" rowspan="1">88.4%</td>
<td align="left" colspan="1" rowspan="1">–</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">PhyML 3.0 (JTT+<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e023" xlink:type="simple"/></inline-formula>, SPRs)</td>
<td align="left" colspan="1" rowspan="1">89.9%</td>
<td align="left" colspan="1" rowspan="1">–</td>
<td align="left" colspan="1" rowspan="1">–</td>
<td align="left" colspan="1" rowspan="1">–</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">FastTree 2.0.0 (JTT+CAT or JC+CAT)</td>
<td align="left" colspan="1" rowspan="1">86.9%</td>
<td align="left" colspan="1" rowspan="1">83.7%</td>
<td align="left" colspan="1" rowspan="1">84.3%</td>
<td align="left" colspan="1" rowspan="1">92.1%</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">PhyML 3.0 (JTT+<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e024" xlink:type="simple"/></inline-formula>, no SPRs)</td>
<td align="left" colspan="1" rowspan="1">86.0%</td>
<td align="left" colspan="1" rowspan="1">–</td>
<td align="left" colspan="1" rowspan="1">–</td>
<td align="left" colspan="1" rowspan="1">–</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">FastME 2.06 (log-corrected distances, SPRs)</td>
<td align="left" colspan="1" rowspan="1">80.5%</td>
<td align="left" colspan="1" rowspan="1">78.8%</td>
<td align="left" colspan="1" rowspan="1">77.0%</td>
<td align="left" colspan="1" rowspan="1">–</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">FastTree 2.0.0, no ML NNIs</td>
<td align="left" colspan="1" rowspan="1">80.4%</td>
<td align="left" colspan="1" rowspan="1">78.3%</td>
<td align="left" colspan="1" rowspan="1">76.6%</td>
<td align="left" colspan="1" rowspan="1">91.4%</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">BIONJ (ML distances)</td>
<td align="left" colspan="1" rowspan="1">77.7%</td>
<td align="left" colspan="1" rowspan="1">73.7%</td>
<td align="left" colspan="1" rowspan="1">73.1%</td>
<td align="left" colspan="1" rowspan="1">–</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">Parsimony (RAxML)</td>
<td align="left" colspan="1" rowspan="1">76.8%</td>
<td align="left" colspan="1" rowspan="1">76.5%</td>
<td align="left" colspan="1" rowspan="1">69.4%</td>
<td align="left" colspan="1" rowspan="1">–</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">Neighbor joining (log-corrected distances)</td>
<td align="left" colspan="1" rowspan="1">76.0%</td>
<td align="left" colspan="1" rowspan="1">72.6%</td>
<td align="left" colspan="1" rowspan="1">71.6%</td>
<td align="left" colspan="1" rowspan="1">66.1%</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">Clearcut (log-corrected distances)</td>
<td align="left" colspan="1" rowspan="1">75.5%</td>
<td align="left" colspan="1" rowspan="1">72.3%</td>
<td align="left" colspan="1" rowspan="1">71.5%</td>
<td align="left" colspan="1" rowspan="1">58.1%</td>
</tr>
</tbody>
</table></alternatives><table-wrap-foot><fn id="nt101"><label/><p>For alignments with 5,000 sequences, we used RAxML 7.2.1 with fast convergence; for smaller alignments we used RAxML 7.0.4. An earlier version of PhyML 3 took up to 4 days for individual simulations with 1,250 sequences, even without <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e025" xlink:type="simple"/></inline-formula>, so we did not try to run PhyML 3 with <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e026" xlink:type="simple"/></inline-formula> on the larger simulations.</p></fn></table-wrap-foot></table-wrap>
<p>To test the practical significance of the additional true splits that are found by using ML SPR moves, we examined the local support values reported by PhyML 3. We defined “strongly supported” as having both SH-like local supports and approximate likelihood ratio test (aLRT) supports <xref ref-type="bibr" rid="pone.0009490-Anisimova1">[21]</xref> of 95% or higher. Only 16% of the true splits that are found by PhyML 3 with SPR moves but missed by FastTree 2 were strongly supported. The full distribution of support values is shown in <xref ref-type="fig" rid="pone-0009490-g001">Figure 1</xref>. Conversely, among the strongly supported splits that were found by PhyML 3 with SPRs but not FastTree, 20% were incorrect. Thus, few of the additional true splits have high support, and of the splits that disagree, even the ones that have high support have a significant probability of being incorrect.</p>
<fig id="pone-0009490-g001" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0009490.g001</object-id><label>Figure 1</label><caption>
<title>Local support values for splits found by PhyML with SPR moves and/or FastTree.</title>
<p>We examined local support values for the splits inferred by PhyML 3.0 with <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e027" xlink:type="simple"/></inline-formula> + SPRs on simulated alignments with 250 protein sequences. We classified PhyML's splits as correct and found by both PhyML and FastTree, correct but missed by FastTree, or incorrect. We show the distribution of support values for each class. The right-most bin includes the strongly supported splits (0.95 to 1.0), and the gray dashed line shows the uniform distribution. The support values are PhyML's minimum of the approximate likelihood ratio test <xref ref-type="bibr" rid="pone.0009490-Anisimova1">[21]</xref> and SH-like <xref ref-type="bibr" rid="pone.0009490-Guindon2">[16]</xref>, <xref ref-type="bibr" rid="pone.0009490-Guindon3">[17]</xref> local supports.</p>
</caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0009490.g001" xlink:type="simple"/></fig>
<p>To understand why FastTree 2 was outperforming PhyML 3 with NNI search, we ran PhyML 3 with FastTree's minimum-evolution tree as its starting tree. For the protein simulations with 250 sequences, this improved PhyML's accuracy to 86.8%, which is statistically indistinguishable from FastTree's accuracy of 86.9% (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e028" xlink:type="simple"/></inline-formula>, paired <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e029" xlink:type="simple"/></inline-formula> test, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e030" xlink:type="simple"/></inline-formula>). We also confirmed that FastTree's minimum-evolution phase yields more accurate starting trees than either PhyML 3's approach of using BIONJ with maximum-likelihood distances or RAxML's implementation of parsimony (<xref ref-type="table" rid="pone-0009490-t001">Table 1</xref>).</p>
</sec><sec id="s2b">
<title>CAT-Based Branch Lengths and Local Support Values</title>
<p>Because FastTree 2 does not exhaustively optimize the likelihood, and because it reports branch lengths and local support values that were estimated using the CAT approximation, we compared its branch lengths and local support values to <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e031" xlink:type="simple"/></inline-formula>-based lengths and supports. Specifically, for the protein simulations with 250 sequences, we re-optimized the branch lengths and computed local SH-like support values for the FastTree topologies with PhyML 3 and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e032" xlink:type="simple"/></inline-formula>. (For both tools, we used the Jones-Taylor-Thorton (JTT) model of amino acid evolution.) PhyML's internal branch lengths were well correlated with those from FastTree (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e033" xlink:type="simple"/></inline-formula> = 0.90). For branch lengths of 1.0 or less, the average difference was just 0.01, and for branch lengths between 0.01 and 1.0, the average percent difference was 13%. For internal branch lengths on correct splits, FastTree agreed slightly better with the true lengths (median absolute difference of 0.062 for PhyML and 0.059 for FastTree). Thus, the CAT approximation gave acceptable branch lengths.</p>
<p>If accurate branch lengths are essential, however, then neither the CAT approximation nor the standard <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e034" xlink:type="simple"/></inline-formula> approximation is sufficient. The <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e035" xlink:type="simple"/></inline-formula> approximation was introduced for alignments with just 10 sequences, and four discrete rate categories may not suffice to give accurate likelihoods on larger alignments <xref ref-type="bibr" rid="pone.0009490-Yang1">[15]</xref>, <xref ref-type="bibr" rid="pone.0009490-Galtier1">[22]</xref>. For alignments of 16S ribosomal RNAs, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e036" xlink:type="simple"/></inline-formula> branch lengths can be a factor of two shorter than <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e037" xlink:type="simple"/></inline-formula> branch lengths (<xref ref-type="supplementary-material" rid="pone.0009490.s001">Figure S1</xref>). As explained in <xref ref-type="supplementary-material" rid="pone.0009490.s001">Figure S1</xref>, correcting by the average posterior rate reduces this problem, and FastTree can compute a fast but accurate approximation to <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e038" xlink:type="simple"/></inline-formula>-based lengths.</p>
<p>The local SH-like support values also showed a good correlation between FastTree and PhyML (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e039" xlink:type="simple"/></inline-formula> = 0.90). For splits with local support values of at least 0.9 from either FastTree or PhyML, the average absolute difference was just 0.008, which is not much greater than the sampling error. (For example, with 1,000 bootstraps and 95% support, the standard deviation of support values due to sampling is <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e040" xlink:type="simple"/></inline-formula> = 0.007.) FastTree was less effective than PhyML in distinguishing correct from incorrect splits, but the difference was slight: the area under the receiver operating curve (AOC) was 0.880 instead of 0.887 (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e041" xlink:type="simple"/></inline-formula>, test of <xref ref-type="bibr" rid="pone.0009490-DeLong1">[23]</xref>).</p>
</sec><sec id="s2c">
<title>Effectiveness of Heuristics</title>
<p>We then examined how the topological accuracy of FastTree 2 is affected by its heuristics. As shown in <xref ref-type="table" rid="pone-0009490-t001">Table 1</xref>, the minimum-evolution phase of FastTree, which uses linear SPRs, is not as accurate as FastME 2, a minimum-evolution method that performs exhaustive SPR moves <xref ref-type="bibr" rid="pone.0009490-Hordijk1">[8]</xref>, <xref ref-type="bibr" rid="pone.0009490-Desper1">[12]</xref>. FastME computes distances between internal nodes differently from the minimum-evolution phase of FastTree: FastME uses averages of distances between sequences, while FastTree uses distances between profiles, which are averages of sequences. Nevertheless, FastTree 1 with only NNI moves gave very similar results as FastME with only NNI moves <xref ref-type="bibr" rid="pone.0009490-Price1">[2]</xref>. Thus, we attribute the modest difference in accuracy of the minimum-evolution methods with SPRs to FastTree's heuristics. To eliminate this effect, we ran FastTree with the FastME starting tree. To eliminate the effect of FastTree's ML heuristics, we ran it with exhaustive ML NNIs, and with more exhaustive optimization of branch lengths within each NNI (4 rounds of optimizing branch lengths for each quartet, instead of 1–2 rounds). In combination, FastTree 2 with FastME+SPR starting trees and exhaustive NNIs improved the accuracy on simulated alignments with 5,000 protein sequences from 84.3% to 85.0%. This modest effect illustrates that all of FastTree's heuristics have little effect on accuracy, and that removing them would improve the topology little relative to adding ML SPRs (e.g., RAxML 7.2.1 was 88.4% accurate).</p>
<p>We also tested FastTree on simulations with over 78,000 nucleotide sequences. These simulations are derived from a 16S ribosomal RNA alignment (see <xref ref-type="sec" rid="s4">Methods</xref>). The large size of these simulated alignments makes them a stringent test of FastTree's heuristics. In these simulations, FastTree gave much more accurate topologies than exact neighbor joining or Clearcut <xref ref-type="bibr" rid="pone.0009490-Evans1">[24]</xref>, a faster heuristic variant of neighbor joining (<xref ref-type="table" rid="pone-0009490-t001">Table 1</xref>). (To analyze such large alignments with exact neighbor joining, we used NINJA <xref ref-type="bibr" rid="pone.0009490-Wheeler1">[25]</xref>.) To verify that the heuristics in FastTree's neighbor joining phase do not reduce accuracy, we also ran FastTree with the exact neighbor-joining tree as its starting tree, before doing minimum-evolution NNIs and SPRs and ML NNIs. This gave the same accuracy as the regular FastTree or as FastTree with the fastest settings of its heuristics for the neighbor joining phase (-fastest). All three variants found 92.10% of splits correctly.</p>
<p>It may seem surprising that FastTree can reach accurate topologies when it does not compare all pairs of sequences to each other. However, minimum-evolution NNIs and SPRs are “consistent” – they find correct trees, even if the distances contain some errors, as long as the errors are much smaller than the internal branch lengths <xref ref-type="bibr" rid="pone.0009490-Desper2">[26]</xref>, <xref ref-type="bibr" rid="pone.0009490-Bordewich1">[27]</xref>. In practice, the errors are often larger than the internal branch lengths, but this still probably explains why NNIs and SPRs suffice to find most of the splits correctly.</p>
</sec><sec id="s2d">
<title>Quality of Topologies for Biological Alignments</title>
<p>To confirm that FastTree finds good topologies for genuine alignments, and not just in simulations, we tested it on 16S ribosomal RNAs and on protein families from COG. Although these families are quite large (up to 300,000 or 19,000 members, respectively), we first tested random subsets of just 500 sequences, so that we could run PhyML 3 with <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e042" xlink:type="simple"/></inline-formula>. To measure the quality of the topologies from FastTree 2, PhyML 3, and RAxML 7, we re-optimized the branch lengths with a <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e043" xlink:type="simple"/></inline-formula> model (using RAxML) and compared the resulting likelihoods. As expected from the simulations, FastTree found better topologies than PhyML 3 with <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e044" xlink:type="simple"/></inline-formula> and NNI moves, but not as good as RAxML 7 (<xref ref-type="table" rid="pone-0009490-t002">Table 2</xref>).</p>
<table-wrap id="pone-0009490-t002" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0009490.t002</object-id><label>Table 2</label><caption>
<title>Average log-likelihood for genuine alignments with 500 sequences.</title>
</caption><!--===== Grouping alternate versions of objects =====--><alternatives><graphic id="pone-0009490-t002-2" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0009490.t002" xlink:type="simple"/><table><colgroup span="1"><col align="left" span="1"/><col align="center" span="1"/><col align="center" span="1"/></colgroup>
<thead>
<tr>
<td align="left" colspan="1" rowspan="1">Method</td>
<td align="left" colspan="1" rowspan="1">16S</td>
<td align="left" colspan="1" rowspan="1">COG</td>
</tr>
</thead>
<tbody>
<tr>
<td align="left" colspan="1" rowspan="1">RAxML 7.0.4 (GTR+CAT or JTT+CAT, SPRs)</td>
<td align="left" colspan="1" rowspan="1">−168,104</td>
<td align="left" colspan="1" rowspan="1">−206,724</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">FastTree 2.0.0 (GTR+CAT or JTT+CAT)</td>
<td align="left" colspan="1" rowspan="1">−168,577</td>
<td align="left" colspan="1" rowspan="1">−206,993</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">PhyML 3.0 (GTR+<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e045" xlink:type="simple"/></inline-formula> or JTT+<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e046" xlink:type="simple"/></inline-formula>, no SPRs)</td>
<td align="left" colspan="1" rowspan="1">−168,603</td>
<td align="left" colspan="1" rowspan="1">−207,156</td>
</tr>
</tbody>
</table></alternatives><table-wrap-foot><fn id="nt102"><label/><p>For all topologies, the log likelihood was computed with RAxML 7, re-optimized branch lengths and model parameters, and the GTR+<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e047" xlink:type="simple"/></inline-formula> or JTT+<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e048" xlink:type="simple"/></inline-formula> models for 16S or COG, respectively. All differences between FastTree and other methods were statistically significant (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e049" xlink:type="simple"/></inline-formula>) except for the comparison with PhyML on 16S rRNAs (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e050" xlink:type="simple"/></inline-formula>, paired <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e051" xlink:type="simple"/></inline-formula> test).</p></fn></table-wrap-foot></table-wrap>
<p>We then tested FastTree and RAxML on larger alignments of 16S rRNAs and COGs. For alignments with thousands of sequences, RAxML 7.0.4 is a bit slow, so we used RAxML 7.2.1, which introduced a fast convergence option as well as other optimizations. With fast convergence, RAxML terminates the search if less than 1% of splits change during a round of SPR moves. As shown in <xref ref-type="table" rid="pone-0009490-t001">Table 1</xref>, for 5,000 proteins, RAxML with fast convergence is nevertheless quite accurate.</p>
<p>On the larger alignments, RAxML 7.2.1's likelihoods were much higher than FastTree's, and all of the differences in likelihood were statistically significant (all <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e052" xlink:type="simple"/></inline-formula>, SH test using CONSEL <xref ref-type="bibr" rid="pone.0009490-Shimodaira2">[28]</xref>). However, FastTree did find most of the splits in the RAxML topology that had strong support (<xref ref-type="table" rid="pone-0009490-t003">Table 3</xref>). For example, FastTree found 96–98% of RAxML's splits that had global bootstrap of 90% or higher.</p>
<table-wrap id="pone-0009490-t003" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0009490.t003</object-id><label>Table 3</label><caption>
<title>Comparison of RAxML and FastTree's log likelihoods, and the agreement of FastTree with RAxML's well-supported splits, for large genuine alignments.</title>
</caption><!--===== Grouping alternate versions of objects =====--><alternatives><graphic id="pone-0009490-t003-3" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0009490.t003" xlink:type="simple"/><table><colgroup span="1"><col align="left" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/></colgroup>
<thead>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1">16S rRNA</td>
<td align="left" colspan="1" rowspan="1">16S rRNA</td>
<td align="left" colspan="1" rowspan="1">7 COGs</td>
</tr>
</thead>
<tbody>
<tr>
<td align="left" colspan="1" rowspan="1">Number of sequences</td>
<td align="left" colspan="1" rowspan="1">4,114</td>
<td align="left" colspan="1" rowspan="1">6,718</td>
<td align="left" colspan="1" rowspan="1">2,500</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">RAxML 7's Log Likelihood</td>
<td align="left" colspan="1" rowspan="1">−325,581</td>
<td align="left" colspan="1" rowspan="1">−481,259</td>
<td align="left" colspan="1" rowspan="1">−1,238,666</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">FastTree 2's Log Likelihood</td>
<td align="left" colspan="1" rowspan="1">−328,062</td>
<td align="left" colspan="1" rowspan="1">−493,841</td>
<td align="left" colspan="1" rowspan="1">−1,240,916</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">Difference</td>
<td align="left" colspan="1" rowspan="1">2,481</td>
<td align="left" colspan="1" rowspan="1">12,582</td>
<td align="left" colspan="1" rowspan="1">2,251</td>
</tr>
<tr>
<td align="left" colspan="4" rowspan="1">Well-supported RAxML splits (bootstrap<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e053" xlink:type="simple"/></inline-formula>0.9)</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">Total in RAxML tree</td>
<td align="left" colspan="1" rowspan="1">851</td>
<td align="left" colspan="1" rowspan="1">1,124</td>
<td align="left" colspan="1" rowspan="1">–</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">Found by FastTree</td>
<td align="left" colspan="1" rowspan="1">837</td>
<td align="left" colspan="1" rowspan="1">1,075</td>
<td align="left" colspan="1" rowspan="1">–</td>
</tr>
<tr>
<td align="left" colspan="4" rowspan="1">Weakly-supported RAxML splits (bootstrap 0.8–0.9)</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">Total in RAxML tree</td>
<td align="left" colspan="1" rowspan="1">265</td>
<td align="left" colspan="1" rowspan="1">419</td>
<td align="left" colspan="1" rowspan="1">–</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">Found by FastTree</td>
<td align="left" colspan="1" rowspan="1">250</td>
<td align="left" colspan="1" rowspan="1">365</td>
<td align="left" colspan="1" rowspan="1">–</td>
</tr>
<tr>
<td align="left" colspan="4" rowspan="1">Locally-supported RAxML splits (SH<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e054" xlink:type="simple"/></inline-formula>0.95)</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">Total in RAxML tree</td>
<td align="left" colspan="1" rowspan="1">1,336</td>
<td align="left" colspan="1" rowspan="1">1,927</td>
<td align="left" colspan="1" rowspan="1">1,018</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">Found by FastTree</td>
<td align="left" colspan="1" rowspan="1">1,033</td>
<td align="left" colspan="1" rowspan="1">1,319</td>
<td align="left" colspan="1" rowspan="1">889</td>
</tr>
</tbody>
</table></alternatives><table-wrap-foot><fn id="nt103"><label/><p>We ran RAxML with the fast convergence option. All values for COGs are averages over seven families. Log likelihoods for all topologies were computed with RAxML using <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e055" xlink:type="simple"/></inline-formula> and GTR or JTT. Global bootstrap values are from using the standard bootstrap with RAxML 7.0.4 (from <xref ref-type="bibr" rid="pone.0009490-Stamatakis2">[11]</xref>). SH-like local support values for RAxML's topology were computed with FastTree 2, the CAT approximation, and GTR or JTT.</p></fn></table-wrap-foot></table-wrap></sec><sec id="s2e">
<title>Running Time and Memory Required</title>
<p>Finally, we compared the computational performance of FastTree, RAxML, and PhyML, on genuine alignments. As shown in <xref ref-type="table" rid="pone-0009490-t004">Table 4</xref>, for alignments with 500 sequences, FastTree is about 100 times faster than RAxML 7.0.4 when using the same model of evolution, and even faster relative to PhyML 3. For alignments with thousands of sequences, FastTree was still 100–800 times faster than RAxML 7.2.1 with fast convergence of SPRs, while PhyML 3 did not complete in a reasonable amount of time.</p>
<table-wrap id="pone-0009490-t004" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0009490.t004</object-id><label>Table 4</label><caption>
<title>Running time and memory usage on genuine alignments.</title>
</caption><!--===== Grouping alternate versions of objects =====--><alternatives><graphic id="pone-0009490-t004-4" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0009490.t004" xlink:type="simple"/><table><colgroup span="1"><col align="left" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/></colgroup>
<thead>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1">Distinct</td>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="3" rowspan="1">FastTree 2.0.0</td>
<td align="left" colspan="1" rowspan="1">RAxML 7</td>
<td align="left" colspan="1" rowspan="1">PhyML 3</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">Alignment</td>
<td align="left" colspan="1" rowspan="1">Sequences</td>
<td align="left" colspan="1" rowspan="1">Positions</td>
<td align="left" colspan="1" rowspan="1">Model</td>
<td align="left" colspan="1" rowspan="1">Hours</td>
<td align="left" colspan="1" rowspan="1">GB</td>
<td align="left" colspan="1" rowspan="1">Hours</td>
<td align="left" colspan="1" rowspan="1">Hours</td>
</tr>
</thead>
<tbody>
<tr>
<td align="left" colspan="1" rowspan="1">16S rRNA, subsets</td>
<td align="left" colspan="1" rowspan="1">500</td>
<td align="left" colspan="1" rowspan="1">1,287 nt.</td>
<td align="left" colspan="1" rowspan="1">GTR</td>
<td align="left" colspan="1" rowspan="1">0.02</td>
<td align="left" colspan="1" rowspan="1">–</td>
<td align="left" colspan="1" rowspan="1">2.2</td>
<td align="left" colspan="1" rowspan="1">2.9</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">COGs, subsets</td>
<td align="left" colspan="1" rowspan="1">500</td>
<td align="left" colspan="1" rowspan="1">65–1,009 a.a.</td>
<td align="left" colspan="1" rowspan="1">JTT</td>
<td align="left" colspan="1" rowspan="1">0.02</td>
<td align="left" colspan="1" rowspan="1">–</td>
<td align="left" colspan="1" rowspan="1">5.2</td>
<td align="left" colspan="1" rowspan="1">7.2</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">COGs, subsets</td>
<td align="left" colspan="1" rowspan="1">2,500</td>
<td align="left" colspan="1" rowspan="1">197–384 a.a.</td>
<td align="left" colspan="1" rowspan="1">JTT</td>
<td align="left" colspan="1" rowspan="1">0.11</td>
<td align="left" colspan="1" rowspan="1">–</td>
<td align="left" colspan="1" rowspan="1">61</td>
<td align="left" colspan="1" rowspan="1">–</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">Efflux permeases</td>
<td align="left" colspan="1" rowspan="1">8,362</td>
<td align="left" colspan="1" rowspan="1">394 a.a.</td>
<td align="left" colspan="1" rowspan="1">JTT</td>
<td align="left" colspan="1" rowspan="1">0.25</td>
<td align="left" colspan="1" rowspan="1">0.35</td>
<td align="left" colspan="1" rowspan="1">197</td>
<td align="left" colspan="1" rowspan="1"><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e056" xlink:type="simple"/></inline-formula>1,200</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">16S rRNAs, families</td>
<td align="left" colspan="1" rowspan="1">15,011</td>
<td align="left" colspan="1" rowspan="1">1,287 nt.</td>
<td align="left" colspan="1" rowspan="1">GTR</td>
<td align="left" colspan="1" rowspan="1">0.66</td>
<td align="left" colspan="1" rowspan="1">0.56</td>
<td align="left" colspan="1" rowspan="1">64</td>
<td align="left" colspan="1" rowspan="1"><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e057" xlink:type="simple"/></inline-formula>2,000</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">ABC transporters</td>
<td align="left" colspan="1" rowspan="1">39,092</td>
<td align="left" colspan="1" rowspan="1">214 a.a.</td>
<td align="left" colspan="1" rowspan="1">JTT</td>
<td align="left" colspan="1" rowspan="1">1.02</td>
<td align="left" colspan="1" rowspan="1">0.96</td>
<td align="left" colspan="1" rowspan="1">–</td>
<td align="left" colspan="1" rowspan="1">–</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1">16S rRNAs, all</td>
<td align="left" colspan="1" rowspan="1">237,882</td>
<td align="left" colspan="1" rowspan="1">1,287 nt.</td>
<td align="left" colspan="1" rowspan="1">JC</td>
<td align="left" colspan="1" rowspan="1">21.8</td>
<td align="left" colspan="1" rowspan="1">5.8</td>
<td align="left" colspan="1" rowspan="1">–</td>
<td align="left" colspan="1" rowspan="1">–</td>
</tr>
</tbody>
</table></alternatives><table-wrap-foot><fn id="nt104"><label/><p>All runs used a single thread of execution. All runs accounted for variable rates across sites, using CAT for RAxML 7 and FastTree 2 or <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e058" xlink:type="simple"/></inline-formula> for PhyML 3. All FastTree runs include local SH-like supports and all RAxML runs include branch lengths under <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e059" xlink:type="simple"/></inline-formula>. RAxML and PhyML were run without support values (no bootstrap). For random subsets of 500 16S rRNAs or for COGs, we show average running times. For alignments with over 1,000 sequences, we used RAxML 7.2.1's fast convergence option.</p></fn></table-wrap-foot></table-wrap>
<p>For one of the largest alignments existing today, containing 237,882 16S ribosomal RNAs, FastTree took less than a day and 5.8 GB of memory on a desktop computer. For comparison, given that RAxML took over 2 days for just 15,011 sequences, and optimistically assuming O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e060" xlink:type="simple"/></inline-formula>) scaling, RAxML would take around half a year for the full 16S alignment. Analyzing such alignments with traditional minimum evolution approaches based on a distance matrix would also be prohibitive – just computing and storing all pairwise distances for these sequences, without computing a topology, would require roughly a day and a half and 113 GB of storage.</p>
<p>All of the FastTree times include the computation of local SH-like support values, while the other tools were run without support values. The local support values do not affect FastTree's running time much. For example, across seven COG alignments with 2,500 protein sequences each, the average time for FastTree to infer a tree is 345 seconds, and the average time for it to compute SH-like supports is 51 seconds. For the full alignment of 237,882 16S rRNAs, the supports required just one hour.</p>
<p>Much of the time in RAxML 7.2.1 is spent optimizing the branch lengths under the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e061" xlink:type="simple"/></inline-formula> model, even though the CAT approximation is used to search for a good topology. (RAxML can also perform SPR moves under the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e062" xlink:type="simple"/></inline-formula> model, but we ran it with SPR moves under the CAT model only, followed by optimizing branch lengths under <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e063" xlink:type="simple"/></inline-formula>, because RAxML 7.2.1 does not report CAT-based branch lengths.) If branch lengths are not required, such as during bootstrapping, then RAxML can be 2–3 times faster than shown in <xref ref-type="table" rid="pone-0009490-t004">Table 4</xref>. For example, for 15,011 16S rRNAs, if the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e064" xlink:type="simple"/></inline-formula> phase is removed, then RAxML 7.2.1 takes 30 hours instead of 64 hours, which is still about 45 times slower than FastTree. The <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e065" xlink:type="simple"/></inline-formula> phase of RAxML is also expected to quadruple the memory required. For example, for 15,011 16S rRNAs, FastTree required 0.56 GB of memory, while RAxML with <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e066" xlink:type="simple"/></inline-formula> required 2.6 GB.</p>
</sec><sec id="s2f">
<title>Improvement of Likelihood Over Time</title>
<p>To compare the search strategies of FastTree and RAxML more directly, we compared their improvement in likelihoods over time for a nucleotide alignment of 4,114 16S rRNAs <xref ref-type="bibr" rid="pone.0009490-Stamatakis2">[11]</xref> and for seven protein alignments of COG families with 2,500 members. We ran both methods with the CAT approximation and with either the generalized time-reversible (GTR) model of nucleotide substitution or the JTT model of amino acid substitution. We computed likelihoods for intermediate and final trees with RAxML, re-optimized branch lengths, and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e067" xlink:type="simple"/></inline-formula>. <xref ref-type="fig" rid="pone-0009490-g002">Figure 2</xref> shows the running time and log likelihood for FastTree's minimum-evolution and final tree, for RAxML's initial parsimony tree and successive rounds of SPR moves, and also for RAxML with FastTree's minimum-evolution tree as its starting tree. These times do not include FastTree's support values or RAxML optimizing branch lengths under <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e068" xlink:type="simple"/></inline-formula>.</p>
<fig id="pone-0009490-g002" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0009490.g002</object-id><label>Figure 2</label><caption>
<title>Likelihoods over time for genuine alignments.</title>
<p>Each line shows the time it takes a different tool to reach a given likelihood. For the COG alignments, all times and likelihoods are averages over the seven alignments. For FastTree, we show the time and the improvement in likelihood for the minimum-evolution topology and the final (approximately-ML) topology. For RAxML, we show the maximum parsimony starting topology, the first two rounds of SPR moves, and the final topology (note the interrupted <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e069" xlink:type="simple"/></inline-formula> axis). For RAxML with FastTree's (minimum-evolution) starting tree, we show the starting topology and RAxML's first two rounds of SPR moves.</p>
</caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0009490.g002" xlink:type="simple"/></fig>
<p>Given the same starting tree, FastTree's ML phase improved the likelihood by roughly the same amount as one round of RAxML's SPR moves, and in about 40% of the time (<xref ref-type="fig" rid="pone-0009490-g002">Figure 2</xref>). FastTree's ML phase also performs about as well as one round of RAxML's SPR moves in finding well-supported splits (<xref ref-type="supplementary-material" rid="pone.0009490.s002">Figure S2</xref>). We obtained similar results for other large 16S alignments (<xref ref-type="supplementary-material" rid="pone.0009490.s003">Table S1</xref>). Although this comparison shows that FastTree is initially faster than RAxML, the RAxML's first round of SPR moves is only a fraction of its run time. Most of the difference in speed between FastTree and RAxML is because of RAxML's more thorough search for a better topology and because of RAxML's <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e070" xlink:type="simple"/></inline-formula> branch lengths.</p>
</sec><sec id="s2g">
<title>Starting Trees: Minimum-Evolution versus Maximum Parsimony</title>
<p>RAxML's parsimony phase was 4–17 times slower than FastTree's minimum evolution phase, and generally slower than FastTree with ML NNIs. FastTree's speed advantage grows with larger alignments (data not shown), which is expected because FastTree should scale as O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e071" xlink:type="simple"/></inline-formula>) and RAxML's parsimony phase uses randomized stepwise addition, which scales as O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e072" xlink:type="simple"/></inline-formula>), as well as limited parsimony-based SPR moves. There are faster implementations of parsimony, such as RAxML 7.2.5 (which was released after we conducted the above experiments) or TNT <xref ref-type="bibr" rid="pone.0009490-Goloboff1">[29]</xref>, but these still scale as O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e073" xlink:type="simple"/></inline-formula>). For 15,011 16s RNAs, RAxML 7.2.5's parsimony and FastTree's minimum evolution phase take about the same time (data not shown).</p>
<p>As measured by likelihood, FastTree's minimum-evolution starting trees were much better than RAxML's parsimony starting trees for the COG alignments, but much worse for large 16S rRNA alignments (<xref ref-type="fig" rid="pone-0009490-g002">Figure 2</xref> and <xref ref-type="supplementary-material" rid="pone.0009490.s003">Table S1</xref>). The differences in likelihood reflects the criterion, and not merely differences in the search strategy: for the COG alignments, the RAxML parsimony starting trees were more parsimonious than FastTree's minimum-evolution trees (average parsimony scores of 281,237 and 283,125, respectively). Conversely, for the 16S alignment with 4,114 sequences, FastTree's minimum-evolution tree was shorter than the parsimony tree (lengths of 43.0 and 44.6, respectively). For this alignment, the minimum-evolution tree's log likelihood was 2,705 worse than parsimony's, yet minimum evolution found more of the strongly-supported splits in the final RAxML tree: minimum evolution found 826 of the 851 splits with a global bootstrap <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e074" xlink:type="simple"/></inline-formula>90%, while parsimony found 814 of them. Thus, we are not sure if the difference in likelihood is biologically meaningful.</p>
</sec></sec><sec id="s3">
<title>Discussion</title>
<p>We have shown that FastTree 2 computes accurate topologies in a reasonable amount of time for alignments with up to hundreds of thousands of sequences. FastTree is open source software and is available at <ext-link ext-link-type="uri" xlink:href="http://microbesonline.org/fasttree" xlink:type="simple">http://microbesonline.org/fasttree</ext-link>. The C source code is extensively documented and contributions are welcome. FastTree trees for every microbial gene family, including families with tens of thousands of members such as ABC transporters, are available at MicrobesOnline (<ext-link ext-link-type="uri" xlink:href="http://microbesonline.org/" xlink:type="simple">http://microbesonline.org/</ext-link>), along with a “tree-browser” for examining these trees. These trees will be updated from FastTree 1 to FastTree 2 in the next release of MicrobesOnline.</p>
<p>Because DNA sequencing technology is improving rapidly, we expect to have alignments with millions of sequences soon. For these huge alignments, the most computationally demanding step will be the initial neighbor-joining phase. In FastTree 2.0, which is described here, neighbor joining takes O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e075" xlink:type="simple"/></inline-formula>) time and O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e076" xlink:type="simple"/></inline-formula>) space, while the other stages take at most O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e077" xlink:type="simple"/></inline-formula>) time and O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e078" xlink:type="simple"/></inline-formula>) space. For example, for 237,882 16S sequences, the neighbor-joining phase of FastTree 2.0 already takes 10.8 of the 21.8 hours. In FastTree 2.1, we have improved the scaling of time and memory from O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e079" xlink:type="simple"/></inline-formula>) to O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e080" xlink:type="simple"/></inline-formula>), without affecting accuracy in our simulations (data not shown). FastTree 2.1 also supports parallel execution of the key steps in the neighbor-joining phase. To improve scalability further, it might be possible to use a divide-and-conquer method to find clusters of closely related sequences in O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e081" xlink:type="simple"/></inline-formula>) time, as in PartTree <xref ref-type="bibr" rid="pone.0009490-Katoh1">[30]</xref>. In our simulations, PartTree starting trees do not allow FastTree to reach the same accuracy as FastTree's neighbor-joining starting tree does (data not shown), but a divide-and-conquer approach might still suffice to obtain a partially resolved initial tree.</p>
<p>Such huge families also raise challenges for multiple sequence alignment. We have used profile alignment to avoid the challenges of multiple sequence alignment on large families. This works well for 16S RNAs because Infernal takes advantage of highly conserved secondary structure <xref ref-type="bibr" rid="pone.0009490-Nawrocki1">[1]</xref>, but we are not sure that it gives accurate results for diverse protein families. In contrast, traditional progressive multiple sequence alignment methods are not scalable because their output grows as O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e082" xlink:type="simple"/></inline-formula>): there are O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e083" xlink:type="simple"/></inline-formula>) independent insertions, and each insertion requires a new column in the alignment and hence O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e084" xlink:type="simple"/></inline-formula>) storage. However, Fast Statistical Alignment uses an O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e085" xlink:type="simple"/></inline-formula>) representation, both internally and as an output format <xref ref-type="bibr" rid="pone.0009490-Bradley1">[31]</xref>. Combining this representation with fast guide tree construction, it should be possible to build progressive multiple sequence alignments with millions of sequences.</p>
<p>Finally, it is not clear how to assess the quality or reliability of such large trees. Different methods gave very different topologies and large differences in likelihood, and yet few of the differences were well-supported by the bootstrap. In fact, a topology with relatively poor likelihood could have relatively good agreement with the best tree. This could indicate that higher-likelihood trees contain many improvements, but that few of the individual improvements are statistically significant. This is expected if there is limited phylogenetic signal. Alternatively, the bootstrap could be too conservative. Local support values do suggest a greater number of significant differences (<xref ref-type="table" rid="pone-0009490-t003">Table 3</xref>), but local support values may be biased upwards because they do not consider all of the alternate topologies. Further study of these questions is needed.</p>
</sec><sec id="s4" sec-type="materials|methods">
<title>Materials and Methods</title>
<sec id="s4a">
<title>Minimum-Evolution “Linear” Subtree-Pruning-Regrafting</title>
<p>To reduce the number of SPR moves considered from O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e086" xlink:type="simple"/></inline-formula>) to O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e087" xlink:type="simple"/></inline-formula>), FastTree does just two rounds of “linear SPRs.” For each node, FastTree does an exhaustive search for moves up to length two. It extends each of these moves up to a length of 10 along the best choice at each point along the way.</p>
<p>As suggested by Richard Desper and Olivier Gascuel, FastTree treats each potential SPR move as a sequence of NNIs. The change in tree length for the SPR move is then just the sum of the changes due to the NNIs, much as <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e088" xlink:type="simple"/></inline-formula>.</p>
<p>The change in tree length for an NNI from <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e089" xlink:type="simple"/></inline-formula> to <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e090" xlink:type="simple"/></inline-formula>, where A, B, C, and D may be subtrees rather than sequences, is estimated by <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e091" xlink:type="simple"/></inline-formula>. In FastME, which introduced balanced minimum evolution <xref ref-type="bibr" rid="pone.0009490-Desper1">[12]</xref>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e092" xlink:type="simple"/></inline-formula> is a topologically weighted average of distances between the members of A and C. In contrast, in FastTree, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e093" xlink:type="simple"/></inline-formula> is the log-corrected distance between the profiles for the subtrees A and C, and the profile <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e094" xlink:type="simple"/></inline-formula> of a subtree is derived from that of its children by <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e095" xlink:type="simple"/></inline-formula>. (Although FastTree 1 used weighted joins, as in BIONJ, FastTree 2 uses unweighted joins because they are faster, and the slight effect on accuracy is erased by the ML NNIs.) For nucleotide sequences, the log correction is the Jukes-Cantor correction <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e096" xlink:type="simple"/></inline-formula>, where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e097" xlink:type="simple"/></inline-formula> is average dissimilarity of positions across profiles. For amino acid sequences, FastTree uses an empirical log correction similar to that of scoredist <xref ref-type="bibr" rid="pone.0009490-Sonnhammer1">[32]</xref>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e098" xlink:type="simple"/></inline-formula>, where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e099" xlink:type="simple"/></inline-formula> is based on an amino acid dissimilarity matrix derived from the BLOSUM45 similarity matrix.</p>
<p>In FastME, the above formula for the change in tree length is exactly correct because the changes in other branch lengths in the tree can be expressed as combinations of distances that cancel each other out <xref ref-type="bibr" rid="pone.0009490-Desper2">[26]</xref>. In FastTree, however, the formula for the change in tree length is an approximation, because the log-corrected distances do not cancel in this way. Nevertheless, FastTree with NNIs and FastME with NNIs give very similar results <xref ref-type="bibr" rid="pone.0009490-Price1">[2]</xref>, and computing the exact change in total tree length does not improve the accuracy of FastTree's SPRs (data not shown).</p>
</sec><sec id="s4b">
<title>The Maximum-Likelihood Phase</title>
<p>The key data structures for the maximum likelihood phase are the tree topology, the branch lengths, and the posterior distributions for each internal node. (FastTree stores the tree with a trifurcation at the root, but the placement of the root is not biologically meaningful and does not affect the likelihood <xref ref-type="bibr" rid="pone.0009490-Felsenstein1">[5]</xref>.) The posterior distribution for an internal node describes the state of the corresponding ancestor, given the branch lengths and the sequences beneath it. For example, for nucleotide data, it stores the probability that a given site was an A, C, G, or T. FastTree stores posterior distributions for <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e100" xlink:type="simple"/></inline-formula> internal nodes (not for the root), and they require O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e101" xlink:type="simple"/></inline-formula>) space each, where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e102" xlink:type="simple"/></inline-formula> is the alignment's length and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e103" xlink:type="simple"/></inline-formula> is the number of characters in the alphabet.</p>
<p>The key primitive operations are (1) to compute the joint likelihood of two posterior distributions, given the length between them, and (2) to compute the posterior distribution of a parent node given the posterior distributions of its two children and their two branch lengths. These suffice to compute the likelihood of the tree <xref ref-type="bibr" rid="pone.0009490-Felsenstein1">[5]</xref>: for example, the likelihood of the tree (A,B,(C,D)) is <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e104" xlink:type="simple"/></inline-formula> where AB and CD are posterior distributions.</p>
<p>At the beginning of the ML phase, we have a minimum-evolution topology and branch lengths. The steps for the maximum-likelihood phase are:</p>
<list list-type="bullet"><list-item>
<p>Compute an approximate posterior distribution for each node, using the weighted averages of its children. Although the initial posterior distributions are approximate, all future changes to the topology or to the branch lengths will update the posterior distributions to their exact values.</p>
</list-item><list-item>
<p>Optimize all branch lengths for one round, using a simplified model with no parameters (without CAT, and with Jukes-Cantor instead of GTR if GTR was requested).</p>
</list-item><list-item>
<p>Perform one round of ML NNIs, using the simplified model.</p>
</list-item><list-item>
<p>If the GTR model is being used, optimize the nucleotide transition rate parameters, switch from Jukes Cantor to the GTR model and recompute posterior distributions, and optimize all branch lengths for one round with the new model.</p>
</list-item><list-item>
<p>If the CAT model is being used, estimate rate categories for each site, recompute posterior distributions, and optimize all branch lengths for one round with the new model.</p>
</list-item><list-item>
<p>Perform additional rounds of ML NNIs, with subtree skipping and the star topology test.</p>
</list-item><list-item>
<p>Perform a final round of ML NNIs without subtree skipping or the star topology test.</p>
</list-item><list-item>
<p>Optimize all branch lengths for one round.</p>
</list-item><list-item>
<p>Compute SH-like local support values.</p>
</list-item></list>
<sec id="s4b1">
<title>A round of ML NNIs</title>
<p>During each round of NNIs, FastTree visits each node before it visits its parents (depth-first post-order traversal). At each node, it compares the likelihood of the trees <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e105" xlink:type="simple"/></inline-formula>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e106" xlink:type="simple"/></inline-formula>, and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e107" xlink:type="simple"/></inline-formula>, where A and B are its children, C is its sibling, and D is the rest of the tree. During this process, FastTree uses the posterior distributions (or sequences) for A, B, and C and an “up-posterior” D, which represents the rest of the tree. More precisely, the up-posterior D is the posterior distribution of the node's parent N, given all of the nodes that are <italic>not</italic> children of N (see <xref ref-type="fig" rid="pone-0009490-g003">Figure 3</xref>). These up-posteriors can be thought of as a way to temporarily reroot the tree at the current location. In particular, the likelihood of the tree can be computed from the posteriors A, B, C, and D.</p>
<fig id="pone-0009490-g003" position="float"><object-id pub-id-type="doi">10.1371/journal.pone.0009490.g003</object-id><label>Figure 3</label><caption>
<title>Traversing a tree with up-posteriors.</title>
<p>FastTree optimizes the tree near node N by analyzing the posterior distributions for subtrees A, B, and C, as well as the “up-posterior” D.</p>
</caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0009490.g003" xlink:type="simple"/></fig>
<p>The up-posterior for a node can be computed from its parent's up-posterior and its sibling's posterior distribution. FastTree only stores these up-posteriors for the path to the root from its current location in the tree, so they take O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e108" xlink:type="simple"/></inline-formula>) space, where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e109" xlink:type="simple"/></inline-formula> is the maximum depth of the tree. Because FastTree always visits children before their parents, the posterior and up-posterior distributions it uses are up to date, even as the topology changes.</p>
<p>When it visits each node, for each of the three alternate topologies around the node, FastTree optimizes the branch lengths to maximize the likelihood. For the topology <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e110" xlink:type="simple"/></inline-formula>, the five initial branch lengths are set from the current tree. For the other topologies, the branch lengths to A, B, C, and D are maintained, as is the internal branch length. Given a quartet (say <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e111" xlink:type="simple"/></inline-formula>), FastTree first optimizes the branch length between AB and CD, and then the branch length leading to A, B, C, and D. FastTree optimizes each branch length to an accuracy of 0.0001 or 0.1%, whichever is greater. These five optimizations define a round of optimization for the quartet. Within a round of optimization, FastTree reuses some of the internal posterior distributions: it needs posterior distributions for AB and CD so that it can optimize the branch length between AB and CD, and then it needs posterior distributions for BCD, ACD, the new posterior distribution for AB given the new branch lengths to A and B, and finally ABD and ABC.</p>
<p>By default, FastTree optimizes the branch lengths within all three quartet topologies for one round. Any topology that is significantly (5 log-likelihood units) worse than the current topology is abandoned after the first round. If more than one topology remains, then the remaining topologies are optimized for another round. After the rounds of optimization are complete, FastTree updates the topology if necessary. In either case, it updates the branch lengths to the re-optimized values and recomputes the posterior distribution for the node.</p>
<p>A difference of 5 in log likelihood may seem like a small difference, so that the heuristic might miss a good change to the topology. However, optimization of branch lengths after the first round usually leads to small improvements in the log likelihood. For example, if we analyze 40 randomly selected 16S rRNAs with FastTree and the GTR+CAT model, and we increase the rounds of branch length optimization to 4 (-mlacc 4), then the average improvement for any NNI is just 1.1 log-likelihood units in the second round of branch length optimization and just 0.04 in rounds 3 and 4 combined. To put these numbers in perspective, differences in log-likelihood of less than 2 are not statistically significant (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e112" xlink:type="simple"/></inline-formula>, likelihood ratio test), and NNIs with much larger changes in likelihood are common. For the simulated alignments with 5,000 protein sequences, always optimizing for two rounds improved accuracy by a negligible amount (0.03%) and increased the running time by 23%.</p>
</sec><sec id="s4b2">
<title>Optimizing model parameters</title>
<p>After the first round of NNIs, FastTree optimizes any parameters in the model. First, if the GTR model is being used, there are six relative rates to optimize, one for each nucleotide conversion. (The stationary distribution for the transition matrix is set to the empirical frequency of the four nucleotides.) FastTree optimizes the likelihood of the tree (with fixed branch lengths and topology) by numerically optimizing each of the six parameters in the model in turn. With each change in the model, it recomputes all posterior distributions. It then optimizes the six parameters a second time. This does not fully optimize the model parameters, but it gives acceptable results (<xref ref-type="table" rid="pone-0009490-t002">Table 2</xref>).</p>
<p>Second, unless the -nocat option is set, FastTree estimates the rate of evolution at each site. Given the desired number of categories of relative rates <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e113" xlink:type="simple"/></inline-formula>, FastTree selects <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e114" xlink:type="simple"/></inline-formula> values that are logarithmically spaced between <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e115" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e116" xlink:type="simple"/></inline-formula>. By default, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e117" xlink:type="simple"/></inline-formula>, and the relative rates range from 0.05 to 20. For each of these relative rates, FastTree recomputes all posterior distributions and recalculates the log likelihood of the tree at each site. FastTree then uses a Bayesian approach to select which rate to use at each site: FastTree maximizes <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e118" xlink:type="simple"/></inline-formula>, where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e119" xlink:type="simple"/></inline-formula> is a gamma-distributed prior. To avoid overfitting, we made the prior more peaked than real rate variation in alignments: the prior has a shape parameter of 3, a scale parameter of 1/3, and a mean of 1. After choosing the rate categories, FastTree scales the rates so that the average rate across all sites is 1.0.</p>
<p>We confirmed that the Bayesian approach to setting the rate categories prevents overfitting on small alignments. For example, on simulated protein alignments with just 10 sequences (from <xref ref-type="bibr" rid="pone.0009490-Price1">[2]</xref>), adding the CAT model improves FastTree's accuracy from 76.2% to 78.0%. (For comparison, PhyML without <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e120" xlink:type="simple"/></inline-formula> or SPRs was 74.4% accurate <xref ref-type="bibr" rid="pone.0009490-Price1">[2]</xref>.) Conversely, on nucleotide simulations with 24 sequences that (unrealistically) do not contain any rate variation across sites (the fast-evolving alignments of <xref ref-type="bibr" rid="pone.0009490-Desper1">[12]</xref>), the CAT model only reduces accuracy slightly, from 93.6% to 93.4%. (For comparison, PhyML without <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e121" xlink:type="simple"/></inline-formula> or SPRs was 93.6% accurate <xref ref-type="bibr" rid="pone.0009490-Price1">[2]</xref>.)</p>
</sec><sec id="s4b3">
<title>Completing the ML NNIs</title>
<p>In later rounds of NNIs, FastTree uses the more accurate model and it uses two additional heuristics “subtree skipping” and the “star topology test,” which are described below. As discussed in the <xref ref-type="sec" rid="s2">Results</xref>, these heuristics have little effect on accuracy.</p>
<p>If no NNI leads to an improvement of more than 0.1 in the likelihood of any quartet, then FastTree considers the NNIs to have converged. FastTree repeats rounds of NNIs until convergence, up to a limit of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e122" xlink:type="simple"/></inline-formula> rounds, which takes O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e123" xlink:type="simple"/></inline-formula>) time. This is the slowest part of the ML phase. The limit on rounds ensures a predictable running time, but FastTree usually converges before reaching the limit, even for huge alignments such as 237,882 16S rRNA sequences. We chose a <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e124" xlink:type="simple"/></inline-formula> limit so that a misplaced subtree could move all the way across a (roughly balanced) tree, and the factor of 2 is an arbitrary safety factor.</p>
<p>After convergence, FastTree does one final round of ML NNIs with the subtree skipping and the star topology test turned off, as in the first round. We view this as a safety valve for the heuristics. Finally, FastTree does a final round of optimizing the branch lengths and computes the SH-like local supports.</p>
</sec><sec id="s4b4">
<title>Subtree skipping</title>
<p>The intuition behind subtree skipping is that if a subtree has not changed during recent rounds of NNIs, then further attempts to optimize the subtree will be fruitless. Specifically, during ML NNIs, FastTree does not traverse into subtrees that have not seen any significant improvement in likelihood (0.1 log likelihood units) in either of the previous two rounds. Before skipping a subtree, FastTree also checks that none of the nodes adjacent to the parent node were affected by a significantly improving NNI in the previous round. The “subtree skipping” heuristic typically gives a 3-fold speedup, making it the most important of FastTree's ML heuristics. Subtree skipping might be useful for SPR moves as well.</p>
</sec><sec id="s4b5">
<title>Star topology test</title>
<p>If the current topology (A,B,(C,D)) is much better than the star topology (A,B,C,D) then an NNI is unlikely to give an improvement. Specifically, if the current topology is significantly (5 log-likelihood units) more likely than the star topology (after optimizing the internal branch length), then FastTree does not optimize the other branch lengths or consider the two alternate topologies. However, FastTree only uses this heuristic if the node that was unchanged in the last round of NNIs. To approximate the likelihood of the star topology, FastTree uses the likelihood with the minimal internal branch length of 0.0001.</p>
</sec><sec id="s4b6">
<title>Branch lengths</title>
<p>To optimize all branch lengths in the tree at the beginning and end of the ML phase and after optimizing the model parameters, FastTree again uses post-order traversal. At each node, it considers a three-node star topology on the node's children and parent, using the posterior distributions for the two children and the up-posterior for itself. (At the root, it uses all three children instead.) It numerically optimizes these three branch lengths in series for two rounds.</p>
</sec><sec id="s4b7">
<title>SH-like local supports</title>
<p>For each node, the local support is derived from the per-site likelihoods for the current topology and the two alternate (NNI) topologies. For the current topology, FastTree uses the current (already optimized) branch lengths. For the alternate topologies, FastTree optimizes branch lengths for the quartets, as during the NNIs, for up to two rounds. Given the per-site likelihoods for the three topologies, FastTree uses the SH test with 1,000 bootstrap replicates to estimate the confidence in the given split <xref ref-type="bibr" rid="pone.0009490-Shimodaira1">[19]</xref>. If there are poorly resolved nodes nearby, then the support values should be interpreted cautiously, because a high-likelihood alternate topology might not have been considered.</p>
</sec><sec id="s4b8">
<title>Low-level optimization of likelihood computations</title>
<p>Whereas RAxML stores likelihood vectors (that is, the joint likelihood of a subtree and of a given character at an internal node), FastTree stores posterior distributions, which are normalized so that each site's values sum to 1. This may improve numerical stability for huge alignments. To reduce memory usage, FastTree stores these vectors in single-precision floating point. Log-likelihoods for the tree or for specific sites are stored with double precision.</p>
<p>Similar to RAxML, FastTree stores the posterior distributions in a rotated form, multiplied by the eigen-matrix of the transition matrix. (For the Jukes Cantor model, this is not necessary.) This reduces the time for likelihood computations from O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e125" xlink:type="simple"/></inline-formula>) per site to O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e126" xlink:type="simple"/></inline-formula>), while leaving the cost of computing the posterior distribution at O(<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e127" xlink:type="simple"/></inline-formula>) per site (but with a higher constant factor).</p>
<p>While computing the joint likelihood for a pair of posterior distributions, FastTree avoids performing a logarithm at every site by operating on likelihoods instead of log likelihoods. To prevent numerical underflow, FastTree rescales the likelihood by a constant when necessary. It updates a separate (log-likelihood-based) counter whenever it does this. Similarly, when computing the tree's likelihood at each site, for example while optimizing the rate categories, FastTree rescales each site's likelihood if necessary after visiting each node.</p>
<p>FastTree uses SSE2 instructions, a special feature of recent CPUs from Intel and AMD, to operate on 4 single-precision floating point values with one instruction. This speeds up computations for protein alignments by up to 50% (data not shown).</p>
</sec><sec id="s4b9">
<title>Numerical optimization</title>
<p>To find the parameters that optimize the likelihood, FastTree uses Brent's method, a numerical method that iteratively halves the interval it is searching within (<ext-link ext-link-type="uri" xlink:href="http://en.wikipedia.org/wiki/Brents_method" xlink:type="simple">http://en.wikipedia.org/wiki/Brents_method</ext-link>). Because Brent's method only operates in one dimension, FastTree optimizes different parameters in turn, and then repeats the rounds of optimization (for example, it optimizes the first branch length, then the second, then the third, then repeats).</p>
<p>FastTree estimates the initial interval to search within from the initial guess <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e128" xlink:type="simple"/></inline-formula> (e.g., the previous length of the branch) and alternate values <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e129" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e130" xlink:type="simple"/></inline-formula>. If <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e131" xlink:type="simple"/></inline-formula> is below the minimum value, it uses the minimum, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e132" xlink:type="simple"/></inline-formula>, and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e133" xlink:type="simple"/></inline-formula> instead. If the initial guess does not bracket the minimum (that is, the middle value is not better than the two endpoints), then FastTree expands the search interval until it does. However, the small interval is usually adequate. FastTree also terminates optimization if the parameter changes by a small amount or by a small proportion. Together, these modifications eliminate about a third of the evaluations of the likelihood.</p>
</sec></sec><sec id="s4c">
<title>Biological and Simulated Alignments</title>
<p>The simulated protein alignments and the genuine COG alignments were described previously <xref ref-type="bibr" rid="pone.0009490-Price1">[2]</xref>. The 16S alignment with 237,882 distinct sequences was taken from GreenGenes <xref ref-type="bibr" rid="pone.0009490-DeSantis1">[33]</xref> (<ext-link ext-link-type="uri" xlink:href="http://greengenes.lbl.gov" xlink:type="simple">http://greengenes.lbl.gov</ext-link>). The 16S alignment with 15,011 distinct “families” is a non-redundant subset of these sequences (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e134" xlink:type="simple"/></inline-formula> identical). 16S alignments with 500 sequences are also non-redundant random subsets (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e135" xlink:type="simple"/></inline-formula> identical). Other large 16S alignments are from <xref ref-type="bibr" rid="pone.0009490-Stamatakis2">[11]</xref>.</p>
<p>For the 16S-like simulations with 78,132 distinct sequences, we used a maximum-likelihood tree inferred from a non-redundant aligned subset of the full set of 16S sequences (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pone.0009490.e136" xlink:type="simple"/></inline-formula>% identity) by an earlier version of FastTree (1.9) with the Jukes-Cantor model (no CAT). To ensure that the simulated trees were resolvable, which facilitates comparison of methods (but inflates the accuracy of all methods), branch lengths of less than 0.001 were replaced with values of 0.001, which corresponds to roughly one substitution across the internal branch, as the 16S alignment has 1,287 positions. Evolutionary rates for each site were randomly selected from 16 rate categories according to a gamma distribution with a coefficient of variation of 0.7. Given the tree and the rates, sequences were simulated with Rose <xref ref-type="bibr" rid="pone.0009490-Stoye1">[34]</xref> under the HKY model and no transition bias. To allow Rose to handle branch lengths of less than 1%, we set “MeanSubstitution = 0.00134” and multiplied the branch lengths by 1,000.</p>
</sec><sec id="s4d">
<title>Software Used</title>
<p>We used FastTree 2.0.0. We used the July 6 2009 release of the PhyML 3.0 source code and modified BL_MIN from 1.e-10 to 1.e-8 to overcome numerical problems with some of the simulated protein alignments, as suggested by Stepháne Guindon. FastME 2.06 was provided by Olivier Gascuel. RAxML 7.0.4 and 7.2.1 were obtained from the author's web sites. RAxML 7.2.1 was compiled with SSE instructions. NINJA was provided by Travis Wheeler and is available at <ext-link ext-link-type="uri" xlink:href="http://nimbletwist.com/software/ninja/" xlink:type="simple">http://nimbletwist.com/software/ninja/</ext-link>. BIONJ was obtained from <ext-link ext-link-type="uri" xlink:href="http://www.lirmm.fr/~w3ifa/MAAS/BIONJ/BIONJ.c" xlink:type="simple">http://www.lirmm.fr/~w3ifa/MAAS/BIONJ/BIONJ.c</ext-link>. BIONJ was run with maximum-likelihood distances obtained with phylip's protdist (<ext-link ext-link-type="uri" xlink:href="http://evolution.genetics.washington.edu/phylip.htm" xlink:type="simple">http://evolution.genetics.washington.edu/phylip.htm</ext-link>) and the JTT model (no gamma). Log-corrected distances were obtained with FastTree and the -makematrix option.</p>
</sec></sec><sec id="s5">
<title>Supporting Information</title>
<supplementary-material id="pone.0009490.s001" mimetype="application/postscript" position="float" xlink:href="info:doi/10.1371/journal.pone.0009490.s001" xlink:type="simple"><label>Figure S1</label><caption>
<p>Branch lengths for an alignment of 200 16S rRNA sequences vary systematically with the Γ approximation used. The CAT lengths are from FastTree, and all Γ branch lengths are from PhyML with FastTree's topology and with optimized shape parameters. The top panel shows that branch lengths from the various models have a roughly linear relationship with each other, but they have different scales. The bottom panel shows how the total length of the tree varies with the number of categories (note log χ axis). The “Use Median” lengths are from running PhyML with –use_median, which uses the median of each region, rather than the mean, to approximate the gamma distribution. The “Corrected” lengths are the “Use Median” lengths multiplied by the average posterior rates, which can be obtained by running PhyML with –print_site_lnl (thanks to Stepháne Guindon for pointing this out). The corrected lengths converge to the correct value much more quickly than the other rates. The “CAT/Gamma” tree length, from FastTree 2.1 with -gamma, is also reasonably accurate. With this option, FastTree 2.1 optimizes the Γ<sub>20</sub> likelihood with a shape parameter and a rescaling parameter, using the site likelihoods from FastTree's 20 relative rates and branch lengths that were optimized under the CAT model.</p>
<p>(0.13 MB PS)</p>
</caption></supplementary-material><supplementary-material id="pone.0009490.s002" mimetype="application/postscript" position="float" xlink:href="info:doi/10.1371/journal.pone.0009490.s002" xlink:type="simple"><label>Figure S2</label><caption>
<p>Total Splits or Strongly Supported Splits that Disagree with RAxML's Final Tree, versus Time. The 16S tree has 4,111 splits and the COG trees have 2,497 splits each. All values for the COG trees are averages over the 7 COGs.</p>
<p>(0.02 MB PS)</p>
</caption></supplementary-material><supplementary-material id="pone.0009490.s003" mimetype="application/pdf" position="float" xlink:href="info:doi/10.1371/journal.pone.0009490.s003" xlink:type="simple"><label>Table S1</label><caption>
<p>Times and likelihoods for large 16S rRNA alignments</p>
<p>(0.02 MB PDF)</p>
</caption></supplementary-material></sec></body>
<back>
<ack>
<p>We thank Alexandros Stamatakis for suggesting the time-and-likelihood comparison between FastTree and RAxML and for commenting on the manuscript.</p>
</ack>
<ref-list>
<title>References</title>
<ref id="pone.0009490-Nawrocki1"><label>1</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Nawrocki</surname><given-names>EP</given-names></name>
<name name-style="western"><surname>Kolbe</surname><given-names>DL</given-names></name>
<name name-style="western"><surname>Eddy</surname><given-names>SR</given-names></name>
</person-group>             <year>2009</year>             <article-title>Infernal 1.0: inference of RNA alignments.</article-title>             <source>Bioinformatics</source>             <volume>15</volume>             <fpage>1335</fpage>             <lpage>7</lpage>          </element-citation></ref>
<ref id="pone.0009490-Price1"><label>2</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Price</surname><given-names>MN</given-names></name>
<name name-style="western"><surname>Dehal</surname><given-names>PS</given-names></name>
<name name-style="western"><surname>Arkin</surname><given-names>AP</given-names></name>
</person-group>             <year>2009</year>             <article-title>FastTree: computing large minimum evolution trees with profiles instead of a distance matrix.</article-title>             <source>Mol Biol Evol</source>             <volume>26</volume>             <fpage>1641</fpage>             <lpage>50</lpage>          </element-citation></ref>
<ref id="pone.0009490-Saitou1"><label>3</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Saitou</surname><given-names>N</given-names></name>
<name name-style="western"><surname>Nei</surname><given-names>M</given-names></name>
</person-group>             <year>1987</year>             <article-title>The neighbor-joining method: a new method for reconstructing phylogenetic trees.</article-title>             <source>Mol Biol Evol</source>             <volume>4</volume>             <fpage>406</fpage>             <lpage>425</lpage>          </element-citation></ref>
<ref id="pone.0009490-Studier1"><label>4</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Studier</surname><given-names>JA</given-names></name>
<name name-style="western"><surname>Keppler</surname><given-names>KJ</given-names></name>
</person-group>             <year>1988</year>             <article-title>A note on the neighbor-joining algorithm of Saitou and Nei.</article-title>             <source>Mol Biol Evol</source>             <volume>5</volume>             <fpage>729</fpage>             <lpage>31</lpage>          </element-citation></ref>
<ref id="pone.0009490-Felsenstein1"><label>5</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Felsenstein</surname><given-names>J</given-names></name>
</person-group>             <year>1981</year>             <article-title>Evolutionary trees from dna sequences: A maximum likelihood approach.</article-title>             <source>J Mol Evol</source>             <volume>17</volume>             <fpage>368</fpage>             <lpage>376</lpage>          </element-citation></ref>
<ref id="pone.0009490-Roch1"><label>6</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Roch</surname><given-names>S</given-names></name>
</person-group>             <year>2006</year>             <article-title>A short proof that phylogenetic tree reconstruction by maximum likelihood is hard.</article-title>             <source>IEEE/ACM Trans Comput Biol Bioinform</source>             <volume>3</volume>             <fpage>92</fpage>             <lpage>94</lpage>          </element-citation></ref>
<ref id="pone.0009490-Guindon1"><label>7</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Guindon</surname><given-names>S</given-names></name>
<name name-style="western"><surname>Gascuel</surname><given-names>O</given-names></name>
</person-group>             <year>2003</year>             <article-title>A simple, fast, and accurate algorithm to estimate large phylogenies by maximum likelihood.</article-title>             <source>Syst Biol</source>             <volume>52</volume>             <fpage>696</fpage>             <lpage>704</lpage>          </element-citation></ref>
<ref id="pone.0009490-Hordijk1"><label>8</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Hordijk</surname><given-names>W</given-names></name>
<name name-style="western"><surname>Gascuel</surname><given-names>O</given-names></name>
</person-group>             <year>2005</year>             <article-title>Improving the efficiency of SPR moves in phylogenetic tree search algorithms based on maximum-likelihood.</article-title>             <source>Bioinformatics</source>             <volume>21</volume>             <fpage>4338</fpage>             <lpage>4347</lpage>          </element-citation></ref>
<ref id="pone.0009490-Stamatakis1"><label>9</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Stamatakis</surname><given-names>A</given-names></name>
</person-group>             <year>2006</year>             <article-title>RAxML-VI-HPC: maximum likelihood-based phylogenetic analyses with thousands of taxa and mixed models.</article-title>             <source>Bioinformatics</source>             <volume>22</volume>             <fpage>2688</fpage>             <lpage>2690</lpage>          </element-citation></ref>
<ref id="pone.0009490-Felsenstein2"><label>10</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Felsenstein</surname><given-names>J</given-names></name>
</person-group>             <year>1985</year>             <article-title>Confidence limits on phylogenies: an approach using the bootstrap.</article-title>             <source>Evolution</source>             <volume>39</volume>             <fpage>783</fpage>             <lpage>791</lpage>          </element-citation></ref>
<ref id="pone.0009490-Stamatakis2"><label>11</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Stamatakis</surname><given-names>A</given-names></name>
<name name-style="western"><surname>Hoover</surname><given-names>P</given-names></name>
<name name-style="western"><surname>Rougemont</surname><given-names>J</given-names></name>
</person-group>             <year>2008</year>             <article-title>A rapid bootstrap algorithm for the RAxML web servers.</article-title>             <source>Syst Biol</source>             <volume>57</volume>             <fpage>758</fpage>             <lpage>771</lpage>          </element-citation></ref>
<ref id="pone.0009490-Desper1"><label>12</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Desper</surname><given-names>R</given-names></name>
<name name-style="western"><surname>Gascuel</surname><given-names>O</given-names></name>
</person-group>             <year>2002</year>             <article-title>Fast and accurate phylogeny reconstruction algorithms based on the minimum-evolution principle.</article-title>             <source>Journal of Computational Biology</source>             <volume>9</volume>             <fpage>687</fpage>             <lpage>705</lpage>          </element-citation></ref>
<ref id="pone.0009490-Nei1"><label>13</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Nei</surname><given-names>M</given-names></name>
<name name-style="western"><surname>Kumar</surname><given-names>S</given-names></name>
<name name-style="western"><surname>Takahashi</surname><given-names>K</given-names></name>
</person-group>             <year>1998</year>             <article-title>The optimization principle in phylogenetic analysis tends to give incorrect topologies when the number of nucleotides or amino acids used is small.</article-title>             <source>Proc Natl Acad Sci USA</source>             <volume>95</volume>             <fpage>12390</fpage>             <lpage>7</lpage>          </element-citation></ref>
<ref id="pone.0009490-Stamatakis3"><label>14</label><element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Stamatakis</surname><given-names>A</given-names></name>
</person-group>             <year>2006</year>             <article-title>Phylogenetic models of rate heterogeneity: a high performance computing perspective.</article-title>             <comment>In: Proceedings of the 20th International Parallel and Distributed Processing Symposium (IPDPS)</comment>          </element-citation></ref>
<ref id="pone.0009490-Yang1"><label>15</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Yang</surname><given-names>Z</given-names></name>
</person-group>             <year>1994</year>             <article-title>Maximum likelihood phylogenetic estimation from DNA sequences with variable rates over sites: Approximate methods.</article-title>             <source>J Mol Evol</source>             <volume>39</volume>             <fpage>306</fpage>             <lpage>314</lpage>          </element-citation></ref>
<ref id="pone.0009490-Guindon2"><label>16</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Guindon</surname><given-names>S</given-names></name>
<name name-style="western"><surname>Delsuc</surname><given-names>F</given-names></name>
<name name-style="western"><surname>Dufayard</surname><given-names>JF</given-names></name>
<name name-style="western"><surname>Gascuel</surname><given-names>O</given-names></name>
</person-group>             <year>2009</year>             <article-title>Estimating maximum likelihood phylogenies with PhyML.</article-title>             <source>Methods Mol Biol</source>             <volume>537</volume>             <fpage>113</fpage>             <lpage>37</lpage>          </element-citation></ref>
<ref id="pone.0009490-Guindon3"><label>17</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Guindon</surname><given-names>S</given-names></name>
<name name-style="western"><surname>Dufayard</surname><given-names>J</given-names></name>
<name name-style="western"><surname>Lefort</surname><given-names>V</given-names></name>
<name name-style="western"><surname>MAnisimova</surname></name>
<name name-style="western"><surname>Hordijk</surname><given-names>W</given-names></name>
<etal/></person-group>             <year>2010</year>             <article-title>New algorithms and methods to estimate maximum-likelihood phylogenies: Assessing the performance of PhyML 3.0.</article-title>             <source>Syst Biol</source>             <comment>: in press</comment>          </element-citation></ref>
<ref id="pone.0009490-Gascuel1"><label>18</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Gascuel</surname><given-names>O</given-names></name>
</person-group>             <year>1997</year>             <article-title>BIONJ: an improved version of the NJ algorithm based on a simple model of sequence data.</article-title>             <source>Mol Biol Evol</source>             <volume>14</volume>             <fpage>685</fpage>             <lpage>695</lpage>          </element-citation></ref>
<ref id="pone.0009490-Shimodaira1"><label>19</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Shimodaira</surname><given-names>H</given-names></name>
<name name-style="western"><surname>Hasegawa</surname><given-names>M</given-names></name>
</person-group>             <year>1999</year>             <article-title>Multiple comparisons of log-likelihoods with applications to phylogenetic inference.</article-title>             <source>Mol Biol Evol</source>             <volume>16</volume>             <fpage>1114</fpage>             <lpage>1116</lpage>          </element-citation></ref>
<ref id="pone.0009490-Tatusov1"><label>20</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Tatusov</surname><given-names>RL</given-names></name>
<name name-style="western"><surname>Natale</surname><given-names>DA</given-names></name>
<name name-style="western"><surname>Garkavtsev</surname><given-names>IV</given-names></name>
<name name-style="western"><surname>Tatusova</surname><given-names>TA</given-names></name>
<name name-style="western"><surname>Shankavaram</surname><given-names>UT</given-names></name>
<etal/></person-group>             <year>2001</year>             <article-title>The COG database: new developments in phylogenetic classification of proteins from complete genomes.</article-title>             <source>Nucleic Acids Res</source>             <volume>29</volume>             <fpage>22</fpage>             <lpage>8</lpage>          </element-citation></ref>
<ref id="pone.0009490-Anisimova1"><label>21</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Anisimova</surname><given-names>M</given-names></name>
<name name-style="western"><surname>Gascuel</surname><given-names>O</given-names></name>
</person-group>             <year>2006</year>             <article-title>Approximate likelihood-ratio test for branches: A fast, accurate, and powerful alternative.</article-title>             <source>Syst Biol</source>             <volume>55</volume>             <fpage>539</fpage>             <lpage>52</lpage>          </element-citation></ref>
<ref id="pone.0009490-Galtier1"><label>22</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Galtier</surname><given-names>N</given-names></name>
<name name-style="western"><surname>Jean-Marie</surname><given-names>A</given-names></name>
</person-group>             <year>2004</year>             <article-title>Markov-modulated markov chains and the covarion process of molecular evolution.</article-title>             <source>J Comput Biol</source>             <volume>11</volume>             <fpage>727</fpage>             <lpage>733</lpage>          </element-citation></ref>
<ref id="pone.0009490-DeLong1"><label>23</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>DeLong</surname><given-names>ER</given-names></name>
<name name-style="western"><surname>Clarke-Pearson</surname><given-names>DL</given-names></name>
</person-group>             <year>1998</year>             <article-title>Comparing the areas under two or more correlated receiver operating characteristic curves: a nonparametric approach.</article-title>             <source>Biometrics</source>             <volume>44</volume>             <fpage>837</fpage>             <lpage>45</lpage>          </element-citation></ref>
<ref id="pone.0009490-Evans1"><label>24</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Evans</surname><given-names>J</given-names></name>
<name name-style="western"><surname>Sheneman</surname><given-names>L</given-names></name>
<name name-style="western"><surname>Foster</surname><given-names>J</given-names></name>
</person-group>             <year>2006</year>             <article-title>Relaxed neighbor joining: a fast distance-based phylogenetic tree construction method.</article-title>             <source>J Mol Evol</source>             <volume>62</volume>             <fpage>785</fpage>             <lpage>92</lpage>          </element-citation></ref>
<ref id="pone.0009490-Wheeler1"><label>25</label><element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Wheeler</surname><given-names>TJ</given-names></name>
</person-group>             <year>2009</year>             <article-title>Large-scale neighbor-joining with NINJA.</article-title>             <comment>In: Proceedings of the 9th Workshop on Algorithms in Bioinformatics</comment>          </element-citation></ref>
<ref id="pone.0009490-Desper2"><label>26</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Desper</surname><given-names>R</given-names></name>
<name name-style="western"><surname>Gascuel</surname><given-names>O</given-names></name>
</person-group>             <year>2004</year>             <article-title>Theoretical foundation of the balanced minimum evolution method of phylogenetic inference and its relationship to weighted least-squares tree fitting.</article-title>             <source>Mol Biol Evol</source>             <volume>21</volume>             <fpage>587</fpage>             <lpage>598</lpage>          </element-citation></ref>
<ref id="pone.0009490-Bordewich1"><label>27</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Bordewich</surname><given-names>M</given-names></name>
<name name-style="western"><surname>Gascuel</surname><given-names>O</given-names></name>
<name name-style="western"><surname>Huber</surname><given-names>KT</given-names></name>
<name name-style="western"><surname>Moulton</surname><given-names>V</given-names></name>
</person-group>             <year>2009</year>             <article-title>Consistency of topological moves based on the balanced minimum evolution principle of phylogenetic inference.</article-title>             <source>IEEE/ACM Trans Comput Biol Bioinform</source>             <volume>6</volume>             <fpage>110</fpage>             <lpage>7</lpage>          </element-citation></ref>
<ref id="pone.0009490-Shimodaira2"><label>28</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Shimodaira</surname><given-names>H</given-names></name>
<name name-style="western"><surname>Hasegawa</surname><given-names>M</given-names></name>
</person-group>             <year>2001</year>             <article-title>CONSEL: for assessing the confidence of phylogenetic tree selection.</article-title>             <source>Bioinformatics</source>             <volume>17</volume>             <fpage>1246</fpage>             <lpage>1247</lpage>          </element-citation></ref>
<ref id="pone.0009490-Goloboff1"><label>29</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Goloboff</surname><given-names>PA</given-names></name>
<name name-style="western"><surname>Farris</surname><given-names>JS</given-names></name>
<name name-style="western"><surname>Nixon</surname><given-names>KC</given-names></name>
</person-group>             <year>2008</year>             <article-title>TNT, a free program for phylogenetic analysis.</article-title>             <source>Cladistics</source>             <volume>24</volume>             <fpage>774</fpage>             <lpage>786</lpage>          </element-citation></ref>
<ref id="pone.0009490-Katoh1"><label>30</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Katoh</surname><given-names>K</given-names></name>
<name name-style="western"><surname>Toh</surname><given-names>H</given-names></name>
</person-group>             <year>2007</year>             <article-title>PartTree: an algorithm to build an approximate tree from a large number of unaligned sequences.</article-title>             <source>Bioinformatics</source>             <volume>23</volume>             <fpage>372</fpage>             <lpage>374</lpage>          </element-citation></ref>
<ref id="pone.0009490-Bradley1"><label>31</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Bradley</surname><given-names>RK</given-names></name>
<name name-style="western"><surname>Roberts</surname><given-names>A</given-names></name>
<name name-style="western"><surname>Smoot</surname><given-names>M</given-names></name>
<name name-style="western"><surname>Juvekar</surname><given-names>S</given-names></name>
<name name-style="western"><surname>Do ea</surname><given-names>J</given-names></name>
</person-group>             <year>2009</year>             <article-title>Fast statistical alignment.</article-title>             <source>PLoS Comput Biol</source>             <volume>5</volume>          </element-citation></ref>
<ref id="pone.0009490-Sonnhammer1"><label>32</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Sonnhammer</surname><given-names>ELL</given-names></name>
<name name-style="western"><surname>Hollich</surname><given-names>V</given-names></name>
</person-group>             <year>2005</year>             <article-title>Scoredist: A simple and robust protein sequence distance estimator.</article-title>             <source>BMC Bioinformatics</source>             <volume>6</volume>             <fpage>108</fpage>          </element-citation></ref>
<ref id="pone.0009490-DeSantis1"><label>33</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>DeSantis</surname><given-names>TZ</given-names></name>
<name name-style="western"><surname>Hugenholtz</surname><given-names>P</given-names></name>
<name name-style="western"><surname>Larsen</surname><given-names>N</given-names></name>
<name name-style="western"><surname>Rojas</surname><given-names>M</given-names></name>
<name name-style="western"><surname>Brodie</surname><given-names>EL</given-names></name>
<etal/></person-group>             <year>2006</year>             <article-title>Greengenes, a chimera-checked 16S rRNA gene database and workbench compatible with ARB.</article-title>             <source>Appl Environ Microbiol</source>             <volume>72</volume>             <fpage>5069</fpage>             <lpage>5072</lpage>          </element-citation></ref>
<ref id="pone.0009490-Stoye1"><label>34</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Stoye</surname><given-names>J</given-names></name>
<name name-style="western"><surname>Evers</surname><given-names>D</given-names></name>
<name name-style="western"><surname>Meyer</surname><given-names>F</given-names></name>
</person-group>             <year>1998</year>             <article-title>Rose: generating sequence families.</article-title>             <source>Bioinformatics</source>             <volume>14</volume>             <fpage>157</fpage>             <lpage>163</lpage>          </element-citation></ref>
</ref-list>

</back>
</article>