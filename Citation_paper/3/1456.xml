<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN" "http://jats.nlm.nih.gov/publishing/1.1d3/JATS-journalpublishing1.dtd">
<article article-type="research-article" dtd-version="1.1d3" xml:lang="en" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">PLoS ONE</journal-id>
<journal-id journal-id-type="publisher-id">plos</journal-id>
<journal-id journal-id-type="pmc">plosone</journal-id>
<journal-title-group>
<journal-title>PLOS ONE</journal-title>
</journal-title-group>
<issn pub-type="epub">1932-6203</issn>
<publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, CA USA</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">PONE-D-17-18308</article-id>
<article-id pub-id-type="doi">10.1371/journal.pone.0184608</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Research Article</subject>
</subj-group>
<subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Molecular biology</subject><subj-group><subject>Molecular biology techniques</subject><subj-group><subject>Genotyping</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Molecular biology techniques</subject><subj-group><subject>Genotyping</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Computational biology</subject><subj-group><subject>Genome analysis</subject><subj-group><subject>Sequence assembly tools</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Genetics</subject><subj-group><subject>Genomics</subject><subj-group><subject>Genome analysis</subject><subj-group><subject>Sequence assembly tools</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Genetics</subject><subj-group><subject>Genomics</subject><subj-group><subject>Human genomics</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Molecular biology</subject><subj-group><subject>Molecular biology techniques</subject><subj-group><subject>Sequencing techniques</subject><subj-group><subject>Genome sequencing</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Molecular biology techniques</subject><subj-group><subject>Sequencing techniques</subject><subj-group><subject>Genome sequencing</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Molecular biology</subject><subj-group><subject>Molecular biology techniques</subject><subj-group><subject>DNA construction</subject><subj-group><subject>DNA library construction</subject><subj-group><subject>Genomic library construction</subject></subj-group></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Molecular biology techniques</subject><subj-group><subject>DNA construction</subject><subj-group><subject>DNA library construction</subject><subj-group><subject>Genomic library construction</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Database and informatics methods</subject><subj-group><subject>Bioinformatics</subject><subj-group><subject>Sequence analysis</subject><subj-group><subject>Sequence alignment</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Simulation and modeling</subject></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Computational biology</subject><subj-group><subject>Comparative genomics</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Genetics</subject><subj-group><subject>Genomics</subject><subj-group><subject>Comparative genomics</subject></subj-group></subj-group></subj-group></subj-group></article-categories>
<title-group>
<article-title>Variant genotyping with gap filling</article-title>
<alt-title alt-title-type="running-head">Variant genotyping with gap filling</alt-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Walve</surname> <given-names>Riku</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Formal analysis</role>
<role content-type="http://credit.casrai.org/">Investigation</role>
<role content-type="http://credit.casrai.org/">Methodology</role>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Validation</role>
<role content-type="http://credit.casrai.org/">Visualization</role>
<role content-type="http://credit.casrai.org/">Writing – original draft</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff001"/>
</contrib>
<contrib contrib-type="author" corresp="yes" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-0756-543X</contrib-id>
<name name-style="western">
<surname>Salmela</surname> <given-names>Leena</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Formal analysis</role>
<role content-type="http://credit.casrai.org/">Funding acquisition</role>
<role content-type="http://credit.casrai.org/">Methodology</role>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Supervision</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff001"/>
<xref ref-type="corresp" rid="cor001">*</xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Mäkinen</surname> <given-names>Veli</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Formal analysis</role>
<role content-type="http://credit.casrai.org/">Funding acquisition</role>
<role content-type="http://credit.casrai.org/">Methodology</role>
<role content-type="http://credit.casrai.org/">Supervision</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff001"/>
</contrib>
</contrib-group>
<aff id="aff001">
<addr-line>Helsinki Institute for Information Technology HIIT, Department of Computer Science, University of Helsinki, Helsinki, Finland</addr-line>
</aff>
<contrib-group>
<contrib contrib-type="editor" xlink:type="simple">
<name name-style="western">
<surname>Scherag</surname> <given-names>Andre</given-names></name>
<role>Editor</role>
<xref ref-type="aff" rid="edit1"/>
</contrib>
</contrib-group>
<aff id="edit1">
<addr-line>University Hospital Jena, GERMANY</addr-line>
</aff>
<author-notes>
<fn fn-type="conflict" id="coi001">
<p>The authors have declared that no competing interests exist.</p>
</fn>
<corresp id="cor001">* E-mail: <email xlink:type="simple">leena.salmela@cs.helsinki.fi</email></corresp>
</author-notes>
<pub-date pub-type="collection">
<year>2017</year>
</pub-date>
<pub-date pub-type="epub">
<day>8</day>
<month>9</month>
<year>2017</year>
</pub-date>
<volume>12</volume>
<issue>9</issue>
<elocation-id>e0184608</elocation-id>
<history>
<date date-type="received">
<day>12</day>
<month>5</month>
<year>2017</year>
</date>
<date date-type="accepted">
<day>28</day>
<month>8</month>
<year>2017</year>
</date>
</history>
<permissions>
<copyright-year>2017</copyright-year>
<copyright-holder>Walve et al</copyright-holder>
<license xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">
<license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="info:doi/10.1371/journal.pone.0184608"/>
<abstract>
<p>Although recent developments in DNA sequencing have allowed for great leaps in both the quality and quantity of genome assembly projects, <italic>de novo</italic> assemblies still lack the efficiency and accuracy required for studying genetic variation of individuals. Thus, efficient and accurate methods for calling and genotyping genetic variants are fundamental to studying the genomes of individuals. We study the problem of genotyping insertion variants. We assume that the location of the insertion is given, and the task is to find the insertion sequence. Insertions are the hardest structural variant to genotype, because the insertion sequence must be assembled from the reads, whereas genotyping other structural variants only requires transformations of the reference genome. The current methods for constructing insertion variants are mostly linked to variation calling methods and are only able to construct small insertions. A sub-problem in genome assembly, the gap filling problem, provides techniques that are readily applicable to insertion genotyping. Gap filling takes the context and length of a missing sequence in a genome assembly and attempts to assemble the intervening sequence. In this paper we show how tools and methods for gap filling can be used to assemble insertion variants by modeling the problem of insertion genotyping as filling gaps in the reference genome. We further give a general read filtering scheme to make the method scalable to large data sets. Our results show that gap filling methods are competitive against insertion genotyping tools. We further show that read filtering improves performance of insertion genotyping especially for long insertions. Our experiments show that on long insertions the new proposed method is the most accurate one, whereas on short insertions it has comparable performance as compared against existing tools.</p>
</abstract>
<funding-group>
<award-group id="award001">
<funding-source>
<institution>Academy of Finland</institution>
</funding-source>
<award-id>284598</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Mäkinen</surname> <given-names>Veli</given-names>
</name>
</principal-award-recipient>
</award-group>
<funding-statement>This work was funded by the Academy of Finland (<ext-link ext-link-type="uri" xlink:href="http://www.aka.fi/en" xlink:type="simple">http://www.aka.fi/en</ext-link>) [grant 284598 (Center of Excellence in Cancer Genetics Research) to VM]. The funder had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
</funding-group>
<counts>
<fig-count count="9"/>
<table-count count="0"/>
<page-count count="12"/>
</counts>
<custom-meta-group>
<custom-meta id="data-availability">
<meta-name>Data Availability</meta-name>
<meta-value>The reference sequence of the human genome version GRCH38 is available in the NCBI Assembly database. The C. elegans genome version WS210 is available in the WormBase database. The Illumina reads used in the experiments are available in the NCBI Sequence Read Archive under accession number SRX523826. The experimentally validated insertion sequences are available as supplementary material for the study by Vergara et al.</meta-value>
</custom-meta>
</custom-meta-group>
</article-meta>
</front>
<body>
<sec id="sec001" sec-type="intro">
<title>Introduction</title>
<p>High-throughput sequencing is today part of the standard toolbox in life science research. However, despite the advances in sequencing technologies fully constructing the genome of an individual, i.e. <italic>de novo</italic> genome assembly, is still a time consuming task especially for large eukaryotic genomes [<xref ref-type="bibr" rid="pone.0184608.ref001">1</xref>]. Thus if a reference genome is available, like for the human genome, usually a resequencing approach is applied to determine the genetic variants in a donor genome as compared to the reference. In a resequencing project, the donor genome is first sequenced, the sequencing reads are then aligned against the reference genome, and finally the genetic variants are inferred based on the aligned reads [<xref ref-type="bibr" rid="pone.0184608.ref002">2</xref>].</p>
<p>Genetic variants are generally split into two groups based on their size. In <italic>single nucleotide polymorphisms</italic>, <italic>SNPs</italic>, a single nucleotide of the donor genome differs from the reference sequence. Larger variants are called <italic>structural variants</italic> and include for example deletions, inversions, insertions, and duplications. The problems of finding the positions of structural variants and <italic>genotyping</italic>, i.e. determining the actual variants, are two different problems although in many tools methods to solve them are intertwined and most tools do their best at answering both questions.</p>
<p>In this paper we will address the insertion genotyping problem. We are given the position of an insertion in a reference genome and a set of sequencing reads from a donor genome. We can now infer the sequences flanking the insertion based on the reference genome and the length of the insertion can be inferred based on paired end sequencing reads. The insertion genotyping problem is then to use the sequencing reads to infer an insertion sequence of correct length that bridges the gap between the flanking sequences. We see that the insertion genotyping problem resembles <italic>de novo</italic> genome assembly, especially when the length of the insertion grows since the task is to infer the part of the sequence not present in the reference genome.</p>
<p>A similar problem is faced in the last phase of <italic>de novo</italic> genome assembly, gap filling. <italic>Gap filling</italic> is the problem of reconstructing the missing sequence between contiguous sections, called <italic>contigs</italic>, of an assembly that have a gap of either an estimated or an unknown length between them. Also in this case the flanks of the missing sequence are known and the task is to infer the missing sequence given the sequencing reads and an estimate of the length of the sequence. In gap filling, the gaps are sections that have proved difficult to assemble. The difficulty arises mainly from two sources, either the section has been sequenced with a low coverage or it contains too much repetitive sequences to unambiguously assemble.</p>
<p>Many genome assemblers, such as Allpaths-LG [<xref ref-type="bibr" rid="pone.0184608.ref003">3</xref>] and ABySS [<xref ref-type="bibr" rid="pone.0184608.ref004">4</xref>], include a gap filling module in their pipelines. There are also standalone gap filling tools available, e.g. SOAPdenovo’s GapCloser [<xref ref-type="bibr" rid="pone.0184608.ref005">5</xref>], GapFiller [<xref ref-type="bibr" rid="pone.0184608.ref006">6</xref>], Gap2Seq [<xref ref-type="bibr" rid="pone.0184608.ref007">7</xref>], MindTheGap [<xref ref-type="bibr" rid="pone.0184608.ref008">8</xref>] and Sealer [<xref ref-type="bibr" rid="pone.0184608.ref009">9</xref>]. All these tools attempt to do <italic>local genome assembly</italic> with a set of reads from the genome but the actual methods used vary. Allpaths-LG uses overlaps within a subset of the reads and GapFiller uses a <italic>k</italic>-mer based method. GapCloser, Gap2Seq, MindTheGap, and Sealer use graph based methods.</p>
<p>In this paper we extend the definition of gap filling to the insertion genotyping problem and modify a gap filling tool, Gap2Seq [<xref ref-type="bibr" rid="pone.0184608.ref007">7</xref>], into an insertion genotyping tool. Among the gap filling tools, Gap2Seq has a unique feature of respecting the length of the gap, making it a robust option as a basis for insertion genotyping. We further introduce and implement a general read filtering scheme to make Gap2Seq scale to large data sets used in resequencing projects and show how it can be applied to insertion genotyping. We investigate experimentally the applicability of gap fillers to the insertion genotyping problem and compare them to tools developed for insertion genotyping. Our results show that insertion genotyping utilizing the insertion length estimate improves the accuracy of insertion genotyping on long insertions significantly.</p>
</sec>
<sec id="sec002" sec-type="materials|methods">
<title>Methods</title>
<sec id="sec003">
<title>Gap filling</title>
<p><italic>De novo</italic> genome assembly attempts to reconstruct the genome of a species based on a set of sequencing reads <italic>R</italic>. In a typical pipeline the reads are first joined into <italic>contigs</italic> which are contiguous sections of the target sequence. Contigs are then ordered into <italic>scaffolds</italic> and finally the gaps between consecutive contigs are filled by reusing the sequencing reads.</p>
<p>Contig assembly is often abstracted as the problem of reconstructing a string from a set of its <italic>k</italic>-mers which can be done using <italic>de Bruijn graphs</italic>. A <italic>k</italic>-th order de Bruijn graph is a directed graph <italic>G</italic> = (<italic>V</italic>, <italic>E</italic>) where vertices <italic>v</italic> ∈ <italic>V</italic> correspond to <italic>k</italic>-mers present in the set of reads and edges (<italic>v</italic>, <italic>v</italic>′) ∈ <italic>E</italic> correspond to observed (<italic>k</italic> + 1)-mers in the reads starting with <italic>v</italic> and ending with <italic>v</italic>′.</p>
<p>Gap filling is the process of reconstructing the missing sequence between consecutive contigs that have a gap of either an estimated or an unknown length between them. Salmela et al. [<xref ref-type="bibr" rid="pone.0184608.ref007">7</xref>] formulate the problem as a modified <italic>exact path length problem</italic>, which we will call the path length problem here.</p>
<p><bold>Definition 1.</bold> <italic>Path Length problem</italic>. Given a directed graph <italic>G</italic> = (<italic>V</italic>, <italic>E</italic>), two vertices <italic>s</italic>, <italic>t</italic> ∈ <italic>V</italic>, a cost function <inline-formula id="pone.0184608.e001"><alternatives><graphic id="pone.0184608.e001g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0184608.e001" xlink:type="simple"/><mml:math display="inline" id="M1"><mml:mrow><mml:mi>c</mml:mi> <mml:mo>:</mml:mo> <mml:mi>E</mml:mi> <mml:mo>→</mml:mo> <mml:msub><mml:mi mathvariant="double-struck">Z</mml:mi> <mml:mrow><mml:mo>≥</mml:mo> <mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, and an interval of path costs [<italic>d</italic>′..<italic>d</italic>], find a path <italic>P</italic> = <italic>v</italic><sub>1</sub><italic>v</italic><sub>2</sub> ⋯ <italic>v</italic><sub><italic>n</italic></sub> such that <italic>v</italic><sub>1</sub> = <italic>s</italic>, <italic>v</italic><sub><italic>n</italic></sub> = <italic>t</italic>, and
<disp-formula id="pone.0184608.e002"><alternatives><graphic id="pone.0184608.e002g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0184608.e002" xlink:type="simple"/><mml:math display="block" id="M2"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo form="prefix">Cost</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>P</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mrow><mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:munderover> <mml:mrow><mml:mi>c</mml:mi> <mml:mo>(</mml:mo> <mml:msub><mml:mi>v</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>v</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>∈</mml:mo> <mml:mrow><mml:mo>[</mml:mo> <mml:msup><mml:mi>d</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>.</mml:mo> <mml:mo>.</mml:mo> <mml:mi>d</mml:mi> <mml:mo>]</mml:mo></mml:mrow> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>The problem was shown to be solvable efficiently with simple dynamic programming [<xref ref-type="bibr" rid="pone.0184608.ref007">7</xref>]. We now give a brief overview of the solution and refer the interested reader to the earlier paper.</p>
<p>We fill a matrix <italic>M</italic>[<italic>v</italic>][<italic>i</italic>], where <italic>v</italic> ∈ <italic>V</italic> and <italic>i</italic> ∈ [1..<italic>d</italic>], such that <italic>M</italic>[<italic>v</italic>][<italic>i</italic>] is the number of paths that reach <italic>v</italic> from <italic>s</italic> and the cost of the path is exactly <italic>i</italic>. This can be done with a breadth-first search in <italic>G</italic> where we increment <italic>M</italic>[<italic>v</italic>][<italic>i</italic>] when we reach <italic>v</italic> from any vertices <italic>w</italic> where <italic>M</italic>[<italic>w</italic>][<italic>i</italic> − <italic>c</italic>(<italic>w</italic>, <italic>v</italic>)] &gt; 0. We then trace back any path <italic>P</italic> = <italic>s</italic> ⋯ <italic>t</italic> where <italic>M</italic>[<italic>t</italic>][<italic>i</italic>] &gt; 0 for any <italic>i</italic> ∈ [<italic>d</italic>′..<italic>d</italic>] and output the labels of the vertices in the path.</p>
<p>Given the de Bruijn graph used for genome assembly, we can trivially define the cost function to be 1 for every edge in the graph, i.e. <italic>c</italic>(<italic>v</italic>, <italic>w</italic>) = 1 if and only if (<italic>v</italic>, <italic>w</italic>) ∈ <italic>E</italic>. Now, as the overlap of connected vertices is always <italic>k</italic> − 1, the cost for a path is its length.</p>
<p><bold>Definition 2.</bold> <italic>Gap Filling problem</italic>. Given a <italic>k</italic>-th order de Bruijn graph <italic>G</italic> = (<italic>V</italic>, <italic>E</italic>), two <italic>k</italic>-mers <italic>s</italic>, <italic>t</italic> ∈ <italic>V</italic>, and an estimated gap length <italic>d</italic>, find a path <italic>P</italic> = <italic>s</italic> ⋯ <italic>t</italic> such that the length of the path is close to <italic>d</italic>.</p>
<p>Using this definition, we can use the solution for the path length problem to find any acceptable solution for the gap filling problem. We only need to consider how to construct the interval [<italic>d</italic>′..<italic>d</italic>] from the estimated gap length. Salmela et al. suggest using an interval, where the midpoint (<italic>d</italic>′ + <italic>d</italic>)/2 is the estimated gap length.</p>
<p>As the sequences around the gap are likely to have assembly errors, allowing the paths to start and end beyond the exact borders of the gap is a simple way to get rid of the errors. GapFiller [<xref ref-type="bibr" rid="pone.0184608.ref006">6</xref>] accomplishes this by simply removing the flanking sequences from the assemblies. Gap2Seq [<xref ref-type="bibr" rid="pone.0184608.ref007">7</xref>] uses a more conservative approach by looking at the paths that start and end at different points in the flanking sequences.</p>
</sec>
<sec id="sec004">
<title>Read filtering</title>
<p>When filling a gap, we would intuitively want to only use the subset of reads that cover the given gap. By restricting the set of reads to those that cover the gap, we can give stricter assumptions about the distribution of the <italic>k</italic>-mers. To find all the reads that cover a region of the scaffold, we will use <italic>read filtering</italic>.</p>
<p>The read filtering problem is defined formally as follows.</p>
<p><bold>Definition 3.</bold> <italic>Read Filtering problem</italic>. Given an interval of a gap [<italic>s</italic>..<italic>e</italic>] and read alignments <italic>A</italic>(<italic>r</italic>) = [<italic>s</italic><sub><italic>r</italic></sub>..<italic>e</italic><sub><italic>r</italic></sub>] for reads <italic>r</italic> ∈ <italic>R</italic>, find reads <italic>r</italic> ∈ <italic>R</italic> that overlap with the gap.</p>
<p>If all reads were aligned, filtering reads would be fairly trivial. However, especially with long insertions all reads do not align, as the reads would have to be aligned to parts that do not exist in the contigs.</p>
<p>We can instead use paired-end reads with at least one end aligned which gives an estimate for the position of the other end. Gap filling methods tackle this problem in different ways. GapFiller [<xref ref-type="bibr" rid="pone.0184608.ref006">6</xref>], for example, takes all the unaligned reads from read pairs with one read aligned within a maximum distance from the gap.</p>
<p>Finding all reads whose pair would be in a region <italic>S</italic> = [<italic>s</italic>..<italic>e</italic>] can also be seen as finding all the reads that map to a region that is defined symmetrically on both sides of <italic>S</italic> by the first and last possible positions a read could start from to have a mate belong to <italic>S</italic>. The regions <italic>S</italic><sub>left</sub> and <italic>S</italic><sub>right</sub> can be defined using the parameters of the original region <italic>S</italic>, the read length <italic>ℓ</italic>, and the expected insert size. The regions are defined as,
<disp-formula id="pone.0184608.e003"><alternatives><graphic id="pone.0184608.e003g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0184608.e003" xlink:type="simple"/><mml:math display="block" id="M3"><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mtext>left</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo> <mml:mrow><mml:mi>s</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext>max</mml:mtext><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mi mathvariant="script">l</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mi>e</mml:mi><mml:mo>−</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext>min</mml:mtext><mml:mo>+</mml:mo><mml:mi mathvariant="script">l</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mtext>right</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo> <mml:mrow><mml:mi>s</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext>min</mml:mtext><mml:mo>+</mml:mo><mml:mi mathvariant="script">l</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo><mml:mo>.</mml:mo><mml:mi>e</mml:mi><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext>max</mml:mtext><mml:mo>+</mml:mo><mml:mi mathvariant="script">l</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:mo>]</mml:mo></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math>
</alternatives></disp-formula>
where max and min are the maximum and minimum insert sizes respectively.</p>
<p>The values for max and min can be computed from the distribution of insert sizes. For example, choosing the insert sizes to be within the 95% confidence interval of the distribution, i.e. <italic>P</italic>(|<italic>X</italic>| ≥ <italic>I</italic>) ≤ 0.05, gives us maximum and minimum insert sizes of <italic>μ</italic> ± 1.96<italic>σ</italic>, where <italic>μ</italic> is the average insert size and <italic>σ</italic> is the standard deviation of the insert size.</p>
<p>Note that we assume reads to be of the same length, which is often the case. The regions could also be defined by giving maximum and minimum read lengths if the read lengths fall into some distribution, such as when using long reads.</p>
<p>As the sequenced reads can be assumed to be read from random positions, we can further assume that all positions are sequenced with equal coverage. Thus we can calculate the expected coverage <inline-formula id="pone.0184608.e004"><alternatives><graphic id="pone.0184608.e004g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0184608.e004" xlink:type="simple"/><mml:math display="inline" id="M4"><mml:mrow><mml:mi>C</mml:mi> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:mo>|</mml:mo> <mml:mi>r</mml:mi> <mml:mi>e</mml:mi> <mml:mi>a</mml:mi> <mml:mi>d</mml:mi> <mml:mi>s</mml:mi> <mml:mo>|</mml:mo></mml:mrow> <mml:mrow><mml:mo>|</mml:mo> <mml:mi>g</mml:mi> <mml:mi>e</mml:mi> <mml:mi>n</mml:mi> <mml:mi>o</mml:mi> <mml:mi>m</mml:mi> <mml:mi>e</mml:mi> <mml:mo>|</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula> and expect the set of filtered reads to have the same coverage <inline-formula id="pone.0184608.e005"><alternatives><graphic id="pone.0184608.e005g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0184608.e005" xlink:type="simple"/><mml:math display="inline" id="M5"><mml:mrow><mml:mfrac><mml:mrow><mml:mo>|</mml:mo> <mml:mi>f</mml:mi> <mml:mi>i</mml:mi> <mml:mi>l</mml:mi> <mml:mi>t</mml:mi> <mml:mi>e</mml:mi> <mml:mi>r</mml:mi> <mml:mi>e</mml:mi> <mml:mi>d</mml:mi> <mml:mtext> </mml:mtext> <mml:mi>r</mml:mi> <mml:mi>e</mml:mi> <mml:mi>a</mml:mi> <mml:mi>d</mml:mi> <mml:mi>s</mml:mi> <mml:mo>|</mml:mo></mml:mrow> <mml:mrow><mml:mo>|</mml:mo> <mml:mi>r</mml:mi> <mml:mi>e</mml:mi> <mml:mi>g</mml:mi> <mml:mi>i</mml:mi> <mml:mi>o</mml:mi> <mml:mi>n</mml:mi> <mml:mo>|</mml:mo></mml:mrow></mml:mfrac> <mml:mo>≈</mml:mo> <mml:mi>C</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>. If the read filtering gives a coverage that is significantly smaller than expected, we are likely to be missing reads that are unmapped. All the unmapped reads can then be added to the set of filtered reads for better gap filling performance.</p>
</sec>
<sec id="sec005">
<title>Insertion genotyping</title>
<p>The insertion genotyping problem can be defined essentially the same way as the gap filling problem.</p>
<p><bold>Definition 4.</bold> <italic>Insertion Genotyping problem</italic>. Given a <italic>k</italic>-th order de Bruijn graph <italic>G</italic> = (<italic>V</italic>, <italic>E</italic>), a breakpoint position <italic>p</italic> on the reference <italic>R</italic>, and an estimated length of insertion <italic>d</italic>, find a path <italic>P</italic> = <italic>s</italic> ⋯ <italic>t</italic> in <italic>G</italic>, such that <italic>s</italic> = <italic>R</italic>[<italic>p</italic> − <italic>k</italic>..<italic>p</italic>], <italic>t</italic> = <italic>R</italic>[<italic>p</italic>..<italic>p</italic> + <italic>k</italic>], and the length of the path is close to <italic>d</italic>.</p>
<p>Using this definition, we can use gap filling to solve insertion genotyping. The main difference is that in gap filling the unresolved gaps are in genomic regions that are hard to assemble, either because of low coverage of reads or because of repetitions, whereas insertions can simply be random sequences inserted to the genome. However, also the insertion sequences are more likely to be repeated sequences from the genome in which case the difficulty is similar to gap filling.</p>
<p>In practice, we can simply take a reference genome and the set of structural variations and for every insertion variant, insert a gap of the estimated length at the corresponding position in the reference genome. Filling the gaps on this sequence then constructs the donor genome.</p>
<p>Although overlapping variations should be taken into consideration, doing so would require accurate knowledge of all the surrounding variations. As we are interested in specifically assembling insertion variants, we will assume no other variations overlap with the flanking sequences.</p>
<p>Note that this assumption is related to the issue of assembly errors in the gap filling problem and similar solutions are useful here. Either completely removing the edges of the flanking sequences or letting the paths skip any parts of them are applicable.</p>
</sec>
</sec>
<sec id="sec006" sec-type="conclusions">
<title>Results and discussion</title>
<sec id="sec007">
<title>Read filtering</title>
<p>Read filtering is evaluated experimentally by generating assemblies from the reference by removing sequences of varying lengths. Reads are then generated from the full reference sequence and mapped to the assemblies and filtered based on the alignments. The filtering is compared to a known truth by mapping the same reads to the reference genome without the gaps and taking all the reads that overlap with a given gap.</p>
<p>The read filtering results can be partitioned into four groups: true positives, reads correctly filtered in; false positives, reads incorrectly filtered in; true negatives, reads correctly filtered out; and false negatives, reads incorrectly filtered out. We then use the metrics <italic>precision</italic> and <italic>recall</italic> to evaluate the filtering scheme:
<disp-formula id="pone.0184608.e006"><alternatives><graphic id="pone.0184608.e006g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0184608.e006" xlink:type="simple"/><mml:math display="block" id="M6"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtext>Precision</mml:mtext></mml:mtd> <mml:mtd><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:mtext>true</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>positives</mml:mtext></mml:mrow> <mml:mrow><mml:mtext>true</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>positives</mml:mtext> <mml:mo>+</mml:mo> <mml:mtext>false</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>positives</mml:mtext></mml:mrow></mml:mfrac> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mtext>Recall</mml:mtext></mml:mtd> <mml:mtd><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:mtext>true</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>positives</mml:mtext></mml:mrow> <mml:mrow><mml:mtext>true</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>positives</mml:mtext> <mml:mo>+</mml:mo> <mml:mtext>false</mml:mtext> <mml:mspace width="4.pt"/><mml:mtext>negatives</mml:mtext></mml:mrow></mml:mfrac> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>The reference genome used to generate reads is chromosome 17 from the version GRCH38 of the human reference genome. The ambiguous bases in the sequence are replaced by random nucleotides, as in the gap filling context they are used to mark gaps in the sequences.</p>
<p>Paired-end reads were generated with ART [<xref ref-type="bibr" rid="pone.0184608.ref010">10</xref>] from the full reference sequence. The simulated reads have a read length of 100 bp and a coverage of 30x. For evaluating the read filtering the threshold for using unmapped reads was set to 25. It should be set close to the coverage of the read libraries, though we will discuss this later in this section. For Gap2Seq, all de Bruijn graphs were built with a fixed <italic>k</italic> of 31, whereas Sealer uses multiple values of <italic>k</italic> and was run with <italic>k</italic> 28 through 34. Other tools used default settings.</p>
<p>We generated three read sets with different insert size distributions. Mean insert sizes for the read sets were 150 bp, 1500 bp, and 3000 bp, and standard deviations were 15, 150, and 300, respectively. These parameters are motivated by the read libraries in the GAGE data sets [<xref ref-type="bibr" rid="pone.0184608.ref011">11</xref>].</p>
<p>To simulate insertion genotyping, for each run of the experiments, we randomly inserted 100 insertions into the reference with lengths randomly chosen between 10 and 1000 bp. The experiments were then averaged over 5 runs. All the scripts used in the simulations can be found at <ext-link ext-link-type="uri" xlink:href="https://github.com/rikuu/eval-insertfill/" xlink:type="simple">https://github.com/rikuu/eval-insertfill/</ext-link>.</p>
<p>We evaluated three read filtering schemes:</p>
<list list-type="bullet">
<list-item>
<p><italic>Unmapped</italic>: All unmapped reads are filtered in.</p>
</list-item>
<list-item>
<p><italic>Filter</italic>: Filtering based on insert size as described in the previous section.</p>
</list-item>
<list-item>
<p><italic>GapFiller</italic>: The filtering used in GapFiller. I.e. pairs of all unmapped reads whose pair aligns within a maximum distance from the gap are filtered in.</p>
</list-item>
</list>
<p>The recall scores in <xref ref-type="fig" rid="pone.0184608.g001">Fig 1a</xref> show that estimating read alignments by paired-end read pairs is useful up to a point. This method fails to find reads from a growing section in the middle of the gap when the gap length exceeds the insert size and no reads can be estimated to cover the middle of the gap.</p>
<fig id="pone.0184608.g001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0184608.g001</object-id>
<label>Fig 1</label>
<caption>
<title>Recall (a) and precision (b) scores for simulated insertions.</title>
<p>Filtering is tested with three simulated read sets with different insert size distributions. As the results for our proposed filtering scheme differ based on the insert size distributions, we have separated and labeled them with the corresponding mean insert sizes, <italic>μ</italic> = 150, 1500, 3000. The other two are averaged over all the read sets. The dashed lines for Filter use only reads that are filtered in and the solid lines add all unmapped reads to the filtered read set if the coverage of the filtered reads is below the coverage threshold (here 25). The precision of using all unmapped reads is almost zero and is thus not visible in the graph.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0184608.g001" xlink:type="simple"/>
</fig>
<p>The recall scores for different insert sizes shows that larger insert sizes generally give better filtering results than smaller insert sizes. However, increasing the mean insert size in practice also increases the standard deviation of the insert size distribution. Thus it also affects the quality of the read pair alignment position estimation.</p>
<p>The precision scores in <xref ref-type="fig" rid="pone.0184608.g001">Fig 1b</xref> show the negative effect of using the unmapped reads in addition to the filtered reads. Due to the fact that the unmapped reads can originate from any insertions, the unmapped reads always give a low precision score.</p>
<p>Finding a good threshold for using the unmapped reads means finding a balance between either having too few reads to find a useful path over the gap or having too many reads to find paths in the graph. That said, we found no meaningful differences between its exact values, only that it should be close to but smaller than the coverage of the read libraries.</p>
</sec>
<sec id="sec008">
<title>Insertion genotyping on simulated data</title>
<p>To evaluate the quality of insertion genotyping, we use the normalized edit distance as a score throughout. The edit distance <italic>ed</italic>(<italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>) of two sequences <italic>S</italic><sub>1</sub> and <italic>S</italic><sub>2</sub> is the minimum number of substitutions, insertions and deletions needed to transform one sequence into the other. We further divide the edit distance by the length of the true sequence to make the results between gap lengths comparable. The score is thus defined as follows:
<disp-formula id="pone.0184608.e007"><alternatives><graphic id="pone.0184608.e007g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pone.0184608.e007" xlink:type="simple"/><mml:math display="block" id="M7"><mml:mrow><mml:mtext>Score</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:mtext>output</mml:mtext> <mml:mo>,</mml:mo> <mml:mtext>correct</mml:mtext> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:mi>e</mml:mi> <mml:mi>d</mml:mi> <mml:mo>(</mml:mo> <mml:mtext>output</mml:mtext> <mml:mo>,</mml:mo> <mml:mtext>correct</mml:mtext> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>|</mml:mo> <mml:mtext>correct</mml:mtext> <mml:mo>|</mml:mo></mml:mrow></mml:mfrac> <mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives></disp-formula>
The perfect score of 0 is achieved with an output that is exactly the correct insertion. A score of 1 means that either the insertion was not genotyped, or that the insertion was genotyped and of the correct length but entirely incorrect content.</p>
<p>To evaluate insertion genotyping we used the same simulated data sets as for evaluating read filtering. <xref ref-type="fig" rid="pone.0184608.g002">Fig 2</xref> shows how the read filtering affects the quality of insertion genotyping. The read filtering should generally perform better with sequencing libraries that have a large insert size but the effect is not very pronounced. This could be due to the fact that the unmapped reads are added when the coverage of the reads filtered in is low.</p>
<fig id="pone.0184608.g002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0184608.g002</object-id>
<label>Fig 2</label>
<caption>
<title>Scores for simulated insertions.</title>
<p>Filtering is simulated with three simulated read sets with different insert size distributions. The filter schemes are labeled with the corresponding mean insert sizes, <italic>μ</italic> = 150, 1500, 3000.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0184608.g002" xlink:type="simple"/>
</fig>
<p>Using all available reads is better at accurately constructing smaller insertions. However, with long insertions the insertion sequences are often not found when using all reads due to the complex graph structure and thus read filtering becomes a requirement for successful insertion genotyping. However, even with read filtering insertion genotyping is not perfect.</p>
<p>Of the three simulated read libraries, the middle one with <italic>μ</italic> = 1500 gives the best result, most likely due to it having both a large insert size and only a modest standard deviation giving a reliable filtering. We used only this read library when running a comparison of different insertion genotyping tools.</p>
<p><xref ref-type="fig" rid="pone.0184608.g003">Fig 3</xref> shows Gap2Seq with and without filtering compared against insertion genotyping tools, Pindel [<xref ref-type="bibr" rid="pone.0184608.ref012">12</xref>] and MindTheGap [<xref ref-type="bibr" rid="pone.0184608.ref008">8</xref>], and other gap filling tools, GapFiller [<xref ref-type="bibr" rid="pone.0184608.ref006">6</xref>], GapCloser [<xref ref-type="bibr" rid="pone.0184608.ref005">5</xref>] and Sealer [<xref ref-type="bibr" rid="pone.0184608.ref009">9</xref>]. The positions of the simulated insertion sites were given as input for MindTheGap, GapFiller, GapCloser and Sealer. Notably, MindTheGap does not take the insertion length as part of its input, rather it outputs insertions for any length it is able to fill. Pindel does not take insertion sites as input but rather estimates the insertion sites itself. However, on this data set Pindel could not find meaningful insertions.</p>
<fig id="pone.0184608.g003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0184608.g003</object-id>
<label>Fig 3</label>
<caption>
<title>Scores for different tools on simulated insertions.</title>
<p>All tools use the same simulated read library with <italic>μ</italic> = 1500.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0184608.g003" xlink:type="simple"/>
</fig>
<p>For short insertion lengths, Gap2Seq with filtering and GapCloser are the most accurate. For long insertions, Gap2Seq with filtering gives by far the most accurate results.</p>
<p>
<xref ref-type="fig" rid="pone.0184608.g004">Fig 4</xref> shows how many insertions each tool is actually able to fill regardless of quality. GapFiller, GapCloser, and Sealer are able to aggressively fill almost all gaps, but as noted before, GapFiller and Sealer do not give reliable quality on any insertion lengths and also the quality of GapCloser is clearly worse than the quality of Gap2Seq with filtering for long insertions. When compared against MindTheGap and Gap2Seq without filtering, Gap2Seq with filtering is able to genotype more insertions with better quality.</p>
<fig id="pone.0184608.g004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0184608.g004</object-id>
<label>Fig 4</label>
<caption>
<title>Number of insertions genotyped on the simulated data by each tool.</title>
<p>All tools use the same simulated read library with <italic>μ</italic> = 1500.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0184608.g004" xlink:type="simple"/>
</fig>
<p>
<xref ref-type="fig" rid="pone.0184608.g005">Fig 5</xref> shows the running times for the various tools on the simulated data. For Gap2Seq with filtering and Pindel we are separately showing the runtime of read alignment and the runtime of actual insertion genotyping (as the light blue bars on top of the runtimes of the tools). We note that usually insertion genotyping is performed along with e.g. SNP calling and thus read alignments are readily available and do not need to be rerun separately for insertion genotyping.</p>
<fig id="pone.0184608.g005" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0184608.g005</object-id>
<label>Fig 5</label>
<caption>
<title>Running times for different tools on simulated insertions.</title>
<p>For Pindel and Gap2Seq with filtering, the time to align reads to reference is shown in light blue. Note that Pindel also uses time to find the insertion sites and as such any direct comparisons are unfair.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0184608.g005" xlink:type="simple"/>
</fig>
<p>In the above experiments the coverage of the read set was always set to 30x. We also ran experiments with coverage 15x and 50x. In Gap2Seq with filtering the threshold for including all unmapped reads depends on the coverage of the data. As mentioned earlier, the threshold should be less than the coverage, yet somewhat close to it. Here we used a threshold of 10 for 15x data and 45 for 50x data. Otherwise the same parameters were used when running the programs.</p>
<p>The results of these experiments are shown in Figs <xref ref-type="fig" rid="pone.0184608.g006">6</xref> and <xref ref-type="fig" rid="pone.0184608.g007">7</xref>. We see that on long insertions the results are similar regardless of coverage but some differences can be seen on short insertions. Additionally we note that the performance of Gap2Seq with filtering suffers from low coverage because erroneously filtering out reads can easier lead to completely missing a part of the insertion when the coverage is low. However, even with the low coverage data, Gap2Seq with filtering is the best method for long insertions.</p>
<fig id="pone.0184608.g006" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0184608.g006</object-id>
<label>Fig 6</label>
<caption>
<title>Scores for different tools on simulated insertions with 15x data.</title>
<p>All tools use the same simulated read library with <italic>μ</italic> = 1500.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0184608.g006" xlink:type="simple"/>
</fig>
<fig id="pone.0184608.g007" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0184608.g007</object-id>
<label>Fig 7</label>
<caption>
<title>Scores for different tools on simulated insertions with 50x data.</title>
<p>All tools use the same simulated read library with <italic>μ</italic> = 1500.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0184608.g007" xlink:type="simple"/>
</fig>
<p>As we noted earlier, we have not found the threshold for including unmapped reads to actually affect the results of the filtering significantly. As such, rather than looking for good parameters, we recommend solving these problematic cases by using Gap2Seq without filtering with low coverage and short insertions.</p>
</sec>
<sec id="sec009">
<title>Biological data</title>
<p>The reference genome in the biological data experiments for insertion genotyping is the WS210 version of the <italic>C. elegans</italic> genome. The donor genome used is the <italic>C. elegans</italic> Hawaiian strain CB4856, more specifically the recent Illumina sequencing SRX523826.</p>
<p>The insertions were evaluated using experimentally validated insertions [<xref ref-type="bibr" rid="pone.0184608.ref013">13</xref>]. We used insertion sites found by Pindel [<xref ref-type="bibr" rid="pone.0184608.ref012">12</xref>], and Breakdancer [<xref ref-type="bibr" rid="pone.0184608.ref014">14</xref>]. Insertion breakpoints found by MindTheGap were not used, as they do not have the corresponding length information for the insertions. However, the combined insertion sites from the aforementioned tools were separately given as input to MindTheGap.</p>
<p>Gap2Seq with and without filtering was again compared against insertion genotyping tools, Pindel [<xref ref-type="bibr" rid="pone.0184608.ref012">12</xref>] and MindTheGap [<xref ref-type="bibr" rid="pone.0184608.ref008">8</xref>], and other gap filling tools, GapFiller [<xref ref-type="bibr" rid="pone.0184608.ref006">6</xref>], and Sealer [<xref ref-type="bibr" rid="pone.0184608.ref009">9</xref>]. <xref ref-type="fig" rid="pone.0184608.g008">Fig 8</xref> shows that for short insertions, GapCloser is the most accurate tool, whereas for longer insertions also Gap2Seq and MindTheGap are competitive. The insertions in this data set were short. Based on the experiments on the simulated data, we expect Gap2Seq with filtering to be competitive for longer insertions.</p>
<fig id="pone.0184608.g008" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0184608.g008</object-id>
<label>Fig 8</label>
<caption>
<title>Scores for insertions constructed by different tools against validated insertions.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0184608.g008" xlink:type="simple"/>
</fig>
<p>
<xref ref-type="fig" rid="pone.0184608.g009">Fig 9</xref> shows how many of the insertions are genotyped by each tool. Although GapFiller and Pindel are able to construct a large number of insertions, the previous results would imply they are aggressively generating low quality sequences.</p>
<fig id="pone.0184608.g009" position="float">
<object-id pub-id-type="doi">10.1371/journal.pone.0184608.g009</object-id>
<label>Fig 9</label>
<caption>
<title>The numbers of insertions genotyped by each tool from the set of insertion sites by Breakdancer and Pindel.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pone.0184608.g009" xlink:type="simple"/>
</fig>
</sec>
</sec>
<sec id="sec010" sec-type="conclusions">
<title>Conclusions</title>
<p>We have shown how gap filling tools developed for <italic>de novo</italic> genome assembly can be applied to the insertion genotyping problem and how the performance of these tools can be improved using read filtering. We note that read filtering can also be useful to boost the performance of gap filling in the <italic>de novo</italic> assembly setting. We showed that our gap filling tool achieves comparable accuracy on short insertions and better accuracy than previous tools on insertion genotyping for long insertions which we believe to be due to read filtering and using the insertion length estimate in a rigorous way.</p>
<p>Last we note that our gap filling tool Gap2Seq has recently been improved with classifying the filled sequence into safe and unsafe bases where safe bases are those that are present in <italic>any</italic> filling sequence of correct length that can be inferred from the read set [<xref ref-type="bibr" rid="pone.0184608.ref015">15</xref>]. We expect this feature to be very useful in the insertion genotyping context because it provides information on the quality of the bases in the returned insertion sequence.</p>
<p>Our method for insertion genotyping, Gap2Seq 3.0, is freely available at <ext-link ext-link-type="uri" xlink:href="https://github.com/rikuu/Gap2Seq/" xlink:type="simple">https://github.com/rikuu/Gap2Seq/</ext-link>.</p>
</sec>
</body>
<back>
<ref-list>
<title>References</title>
<ref id="pone.0184608.ref001">
<label>1</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Bradnam</surname> <given-names>KR</given-names></name>, <name name-style="western"><surname>Fass</surname> <given-names>JN</given-names></name>, <name name-style="western"><surname>Alexandrov</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Baranay</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Bechner</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Birol</surname> <given-names>I</given-names></name>, <etal>et al</etal>. <article-title>Assemblathon 2: evaluating de novo methods of genome assembly in three vertebrate species</article-title>. <source>GigaScience</source>. <year>2013</year> <month>Jul</month>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1186/2047-217X-2-10" xlink:type="simple">10.1186/2047-217X-2-10</ext-link></comment> <object-id pub-id-type="pmid">23870653</object-id></mixed-citation>
</ref>
<ref id="pone.0184608.ref002">
<label>2</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Nielsen</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Paul</surname> <given-names>JS</given-names></name>, <name name-style="western"><surname>Albrechtsen</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Song</surname> <given-names>YS</given-names></name>. <article-title>Genotype and SNP calling from next-generation sequencing data</article-title>. <source>Nat Rev Genet</source>. <year>2011</year> <month>Jun</month> <volume>12</volume>:<fpage>443</fpage>–<lpage>51</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nrg2986" xlink:type="simple">10.1038/nrg2986</ext-link></comment> <object-id pub-id-type="pmid">21587300</object-id></mixed-citation>
</ref>
<ref id="pone.0184608.ref003">
<label>3</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Gnerre</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>MacCallum</surname> <given-names>I</given-names></name>, <name name-style="western"><surname>Przybylski</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Ribeiro</surname> <given-names>FJ</given-names></name>, <name name-style="western"><surname>Burton</surname> <given-names>JN</given-names></name>, <name name-style="western"><surname>Walker</surname> <given-names>BJ</given-names></name>, <etal>et al</etal>. <article-title>High-quality draft assemblies of mammalian genomes from massively parallel sequence data</article-title>. <source>Proc. Natl. Acad. Sci. U.S.A</source>. <year>2011</year> <month>Jan</month>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1073/pnas.1017351108" xlink:type="simple">10.1073/pnas.1017351108</ext-link></comment> <object-id pub-id-type="pmid">21187386</object-id></mixed-citation>
</ref>
<ref id="pone.0184608.ref004">
<label>4</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Simpson</surname> <given-names>JT</given-names></name>, <name name-style="western"><surname>Wong</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Jackman</surname> <given-names>SD</given-names></name>, <name name-style="western"><surname>Schein</surname> <given-names>JE</given-names></name>, <name name-style="western"><surname>Jones</surname> <given-names>SJ</given-names></name>, <name name-style="western"><surname>Birol</surname> <given-names>I</given-names></name>. <article-title>ABySS: a parallel assembler for short read sequence data</article-title>. <source>Genome Res</source>. <year>2009</year> <month>Jun</month>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1101/gr.089532.108" xlink:type="simple">10.1101/gr.089532.108</ext-link></comment> <object-id pub-id-type="pmid">19251739</object-id></mixed-citation>
</ref>
<ref id="pone.0184608.ref005">
<label>5</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Luo</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Liu</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Xie</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Li</surname> <given-names>Z</given-names></name>, <name name-style="western"><surname>Huang</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Yuan</surname> <given-names>J</given-names></name>, <etal>et al</etal>. <article-title>SOAPdenovo2: an empirically improved memory-efficient short-read de novo assembler</article-title>. <source>GigaScience</source>. <year>2012</year> <month>Dec</month>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1186/2047-217X-1-18" xlink:type="simple">10.1186/2047-217X-1-18</ext-link></comment> <object-id pub-id-type="pmid">23587118</object-id></mixed-citation>
</ref>
<ref id="pone.0184608.ref006">
<label>6</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Boetzer</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Pirovano</surname> <given-names>W</given-names></name>. <article-title>Toward almost closed genomes with GapFiller</article-title>. <source>Genome Biol</source>. <year>2012</year> <month>Jun</month>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1186/gb-2012-13-6-r56" xlink:type="simple">10.1186/gb-2012-13-6-r56</ext-link></comment> <object-id pub-id-type="pmid">22731987</object-id></mixed-citation>
</ref>
<ref id="pone.0184608.ref007">
<label>7</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Salmela</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Sahlin</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Mäkinen</surname> <given-names>V</given-names></name>, <name name-style="western"><surname>Tomescu</surname> <given-names>AI</given-names></name>. <article-title>Gap filling as exact path length problem</article-title>. <source>Journal of Computational Biology</source> <volume>23</volume>(<issue>5</issue>);<fpage>347</fpage>–<lpage>361</lpage>. <year>2016</year> <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1089/cmb.2015.0197" xlink:type="simple">10.1089/cmb.2015.0197</ext-link></comment> <object-id pub-id-type="pmid">26959081</object-id></mixed-citation>
</ref>
<ref id="pone.0184608.ref008">
<label>8</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Rizk</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Gouin</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Chikhi</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Lemaitre</surname> <given-names>C</given-names></name>. <article-title>MindTheGap: integrated detection and assembly of short and long insertions</article-title>. <source>Bioinformatics</source>. <year>2014</year> <month>Dec</month>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/bioinformatics/btu545" xlink:type="simple">10.1093/bioinformatics/btu545</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0184608.ref009">
<label>9</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Paulino</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Warren</surname> <given-names>RL</given-names></name>, <name name-style="western"><surname>Vandervalk</surname> <given-names>BP</given-names></name>, <name name-style="western"><surname>Raymond</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Jackman</surname> <given-names>SD</given-names></name>, <name name-style="western"><surname>Birol</surname> <given-names>I</given-names></name>. <article-title>Sealer: a scalable gap-closing application for finishing draft genomes</article-title>. <source>BMC Bioinformatics</source>. <year>2015</year> <month>Jul</month>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1186/s12859-015-0663-4" xlink:type="simple">10.1186/s12859-015-0663-4</ext-link></comment> <object-id pub-id-type="pmid">26209068</object-id></mixed-citation>
</ref>
<ref id="pone.0184608.ref010">
<label>10</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Huang</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Li</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Myers</surname> <given-names>JR</given-names></name>, <name name-style="western"><surname>Marth</surname> <given-names>GT</given-names></name> <article-title>ART: a next-generation sequencing read simulator</article-title> <source>Bioinformatics</source>. <year>2011</year> <month>Dec</month>.</mixed-citation>
</ref>
<ref id="pone.0184608.ref011">
<label>11</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Salzberg</surname> <given-names>SL</given-names></name>, <name name-style="western"><surname>Phillippy</surname> <given-names>AM</given-names></name>, <name name-style="western"><surname>Zimin</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Puiu</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Magoc</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Koren</surname> <given-names>S</given-names></name>, <etal>et al</etal>. <article-title>GAGE: A critical evaluation of genome assemblies and assembly algorithms</article-title>. <source>Genome research</source>, <volume>22</volume>(<issue>3</issue>), pp.<fpage>557</fpage>–<lpage>567</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1101/gr.131383.111" xlink:type="simple">10.1101/gr.131383.111</ext-link></comment> <object-id pub-id-type="pmid">22147368</object-id></mixed-citation>
</ref>
<ref id="pone.0184608.ref012">
<label>12</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Ye</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Schulz</surname> <given-names>MH</given-names></name>, <name name-style="western"><surname>Long</surname> <given-names>Q</given-names></name>, <name name-style="western"><surname>Apweiler</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Ning</surname> <given-names>Z</given-names></name>. <article-title>Pindel: a pattern growth approach to detect break points of large deletions and medium sized insertions from paired-end short reads</article-title>. <source>Bioinformatics</source>. <year>2009</year> <month>Nov</month>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/bioinformatics/btp394" xlink:type="simple">10.1093/bioinformatics/btp394</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0184608.ref013">
<label>13</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Vergara</surname> <given-names>IA</given-names></name>, <name name-style="western"><surname>Tarailo-Graovac</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Frech</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Wang</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Qin</surname> <given-names>Z</given-names></name>, <name name-style="western"><surname>Zhang</surname> <given-names>T</given-names></name>, <etal>et al</etal>. <article-title>Genome-wide variations in a natural isolate of the nematode Caenorhabditis elegans</article-title>. <source>BMC Genomics</source>. <year>2014</year> <month>Apr</month>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1186/1471-2164-15-255" xlink:type="simple">10.1186/1471-2164-15-255</ext-link></comment> <object-id pub-id-type="pmid">24694239</object-id></mixed-citation>
</ref>
<ref id="pone.0184608.ref014">
<label>14</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Chen</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Wallis</surname> <given-names>JW</given-names></name>, <name name-style="western"><surname>McLellan</surname> <given-names>MD</given-names></name>, <name name-style="western"><surname>Larson</surname> <given-names>DE</given-names></name>, <name name-style="western"><surname>Kalicki</surname> <given-names>JM</given-names></name>, <name name-style="western"><surname>Pohl</surname> <given-names>CS</given-names></name>, <etal>et al</etal>. <article-title>BreakDancer: an algorithm for high-resolution mapping of genomic structural variation</article-title>. <source>Nature Methods</source>. <year>2009</year> <month>Aug</month>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nmeth.1363" xlink:type="simple">10.1038/nmeth.1363</ext-link></comment></mixed-citation>
</ref>
<ref id="pone.0184608.ref015">
<label>15</label>
<mixed-citation publication-type="other" xlink:type="simple">Salmela L, Tomescu AI Safely filling gaps with partial solutions common to all solutions In Proc. WABI’16, Workshop on Algorithms in Bioinformatics (ed. M. Frith and C.N.S. Pedersen), LNBI 9838, Springer, 2016, xiv, short abstract.</mixed-citation>
</ref>
</ref-list>
</back>
</article>